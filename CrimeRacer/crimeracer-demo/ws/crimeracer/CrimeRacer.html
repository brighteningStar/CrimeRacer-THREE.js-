<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {

				font-family: Monospace;
				background-color: #50dee7;
				margin: 0px auto;
				overflow: hidden;//
				background-image: url('images/Bodybackground.jpg');
				color: black;
			}
			#hud {
				top: 10px;
				margin-right: 40px;
				position: absolute;
				right: 10px;
				z-index: 100;
				background-color: #05580C;
				opacity: .5;
				border: 1px soild black;
				color: white;
				text-shadow: 0 0 30px #c61a1a;
				font-size: 22px;
				font-style: "Comic Sans MS", cursive, sans-serif;
				font-weight: bold;
				padding-right: 5px;
				padding-left: 5px;
			}
			#intro {
				background-color: #000000;
				color: #FFFFFF;
				cursor: pointer;
				font-size: 32px;
				opacity: 0.7;
				padding: 120px;
				text-align: center;
				z-index: 1001;
			}
			#hurt {
				background-color: red;
				display: none;
				left: 0;
				opacity: 0.15;
				pointer-events: none;
				position: absolute;
				top: 0;
				z-index: 1002;
			}
		</style>
	</head>

	</div>
	<body>

		<script src="threejs/three/jquery-1.7.2.min.js"></script>
		<script src="threejs/three/three.min.js"></script>
		<script src="threejs/three/ShaderExtras.js"></script>
		<script src="threejs/three/CollisionUtils.js"></script>
		<script src="threejs/three/Collisions.js"></script>
		<script src="threejs/three/Stats.js"></script>
		<script src="extras/THREEx.KeyboardState.js"></script>
		<script src="objects/car.js"></script>
		<script src="objects/wall.js"></script>
		<script src="loader/MTLLoader.js"></script>
		<script src="loader/OBJLoader.js"></script>
		<script src="loader/ColladaLoader.js"></script>
		<script src="loader/OBJMTLLoader.js"></script>
		<script src="objects/world.js"></script>
		<script src="objects/tree.js"></script>
		<script src="objects/boxes.js"></script>
		<script src="objects/time.js"></script>
		<script src="objects/enemyCar.js"></script>

		<script>
			var container, stats;
			var camera, scene, renderer;
			var sphere;
			var car;
			var Ncar;
			var enemyCarr = [];
			var speed = 0;
			var Nspeed = 0;
			var acceleration = 3;
			var speedDamping = 1;
			var maxSpeed = 70;
			var cameraYPos = 250;
			var mycar;
			var eneCar;
			var object;
			var carHit = false;
			var box;
			var textu;
			var myWorld = new CrimeRacer.World;
			var distance1 = 0;
			var collideMesh;
			var collidableMeshList = [];
			var collidableMesh = [];
			var bullets = [];
			var localObject;
			var cloc = new THREE.Clock();
			var index = 0;
			var enemy;
			var refrencePoint = [];
			var point;
			var hitCount = 0;
			var checkObj;
			var wall;
			var timer = myWorld.worldTime.currentTime.getSeconds();
			var XPath, YPath, ZPath;
			var Ccar;
			var te = 500;
			var tree;
			var trees = [];
			var loader2 = new THREE.ColladaLoader();
			var bulletOfCar;
			var wheel;
			var locatio = 0;
			var boxArray = [];
			var box;
			var runAnim = true;
			var xWidth = 0;
			var zWidth = 0;
			var xPos = 0;
			var zPos = 0;
			var carr;
			// init();

			// animate();

			loader2.load('obj/us/us_police_car.dae', function colladaReady(collada) {
				localObject = collada.scene;

				localObject.scale.x = localObject.scale.y = localObject.scale.z = 2;
				localObject.updateMatrix();
				localObject.position.x = 500;
				localObject.position.x = 0;
				localObject.position.x = 500;

				localObject.rotation.x = -(Math.PI / 2);

				localObject.rotation.z = (Math.PI / 2);

				//localObject.rotation.z = -(Math.PI / 2);
				//collidableMeshList3 = localObject;
				//console.log(collidableMeshList3);
				//scene.add(localObject);

				init();
				animate();

			});

			function init() {

				container = document.createElement('div');
				document.body.appendChild(container);

				var info = document.createElement('div');

				container.appendChild(info);

				//camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -2000, 1000);
				camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 2, 100000);

				camera.position.set(-1000, 0, 0);

				scene = new THREE.Scene();
				//scene.fog = new THREE.FogExp2(0xD6F1FF, 0.0003);
				// color, density

				var texture = THREE.ImageUtils.loadTexture("images/road.jpg");
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set(3, 3);

				groundBasic = new THREE.MeshLambertMaterial({
					color : 0x473e34,
					map : texture
				});
				groundBasic.color.setHSV(0.1, 0.45, 0.995);

				ground = new THREE.Mesh(new THREE.PlaneGeometry(20000, 20000, 80, 80), groundBasic);
				ground.position.y = 0;
				ground.rotation.x = (-Math.PI / 2);
				ground.rotation.z = Math.PI / 2;
				//ground.rotation.y = -Math.PI / 2;
				ground.receiveShadow = true;

				scene.add(ground);

				$(document).click(function(e) {
					e.preventDefault
					if (e.which === 1) {// Left click only
						object = createBullet();

					}

				});

				$('body').append('<div id="hud"><span id="speed">0</span></br>Health: <span id="health">100</span></br>Enemy Car 1: <span id="enemyHealth1">100</span></br>Enemy Car 2: <span id="enemyHealth2">100</span></br>Enemy Car 3: <span id="enemyHealth3">100</span>');
				// Set up "hurt" flash
				$('body').append('<div id="hurt"></div>');
				$('#hurt').css({
					width : 1366,
					height : 768
				});
				//$('#intro').css({width: 1366, height: 768});

				// Box

				// ========================TREE MAKING============================
				var texture = THREE.ImageUtils.loadTexture("images/wooden.jpg");
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set(.5, .5);
				var boxGeometry = new THREE.CubeGeometry(70, 650, 70);
				var boxMaterial = new THREE.MeshLambertMaterial({
					// color : 0x5CD715,
					shading : THREE.FlatShading,
					overdraw : true,
					map : texture

				});
				for (var k = 0; k < myWorld.noOfTreeSides(); k++) {
					for (var l = 0; l <= myWorld.noOfTress(); l++) {
						// box = new THREE.Mesh(boxGeometry, boxMaterial);

						myWorld.setWorldTreePosition(k);
						
						createTrees(myWorld.myTreePosition.position.x, myWorld.myTreePosition.position.y, myWorld.myTreePosition.position.z);
					}
				}

				
				scene.add(localObject);

				// ========================wall=================================
				var texture = THREE.ImageUtils.loadTexture("images/stone2.jpg");
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set(1, 1);
				var boxGeometry = new THREE.CubeGeometry(100, 500, 100);
				var boxMaterial = new THREE.MeshLambertMaterial({
					color : 0x8A5719,
					shading : THREE.FlatShading,
					overdraw : true,
					map : texture

				});
				for (var k = 1; k <= myWorld.noOfWallSide(); k++) {

					for (var i = 0; i < myWorld.noOfBlockPerBoundryWall(); i++) {

						box = new THREE.Mesh(boxGeometry, boxMaterial);
						scene.add(box);
						collidableMeshList.push(box);
						myWorld.setWallPosition(k);
						box.position.x = myWorld.myWall.position.x;
						box.position.y = myWorld.myWall.position.y;
						box.position.z = myWorld.myWall.position.z;
						box.castShadow = true;
						box.receiveShadow = true;

					}
				}

				var texture = THREE.ImageUtils.loadTexture("images/car.jpg");
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set(.5, .5);

				var carGeometry = new THREE.CubeGeometry(400, 100, 150);
				var carMaterial = new THREE.MeshLambertMaterial({
					color : 0x000000,
					//shading : THREE.FlatShading,
					overdraw : true,
					map : texture
				});

				car = new THREE.Mesh(carGeometry, carMaterial);
				myWorld.setWorldCar();
				car.position.x = localObject.position.x + 10;
				car.position.y = localObject.position.y;
				car.position.z = localObject.position.z;
				car.castShoadow = true;
				car.receiveShadow = true;
				collidableMesh.push(car);
				car.material.wireframe = true;
				scene.add(car);

				var carGeometry = new THREE.CubeGeometry(100, 100, 100);
				var carMaterial = new THREE.MeshLambertMaterial({
					color : 0x000000,
					//shading : THREE.FlatShading,
					overdraw : true,
					map : texture
				});
				for (var k = 1; k <= myWorld.noOfEnemies(); k++) {

					Ncar = new THREE.Mesh(carGeometry, carMaterial);
					myWorld.setWorldEnemyCar(k);
					Ncar.position.x = myWorld.enemyCar.position.x;
					Ncar.position.y = myWorld.enemyCar.position.y;
					Ncar.position.z = myWorld.enemyCar.position.z;
					scene.add(Ncar);
					Ncar.castShoadow = true;
					Ncar.receiveShadow = true;

					Ncar.lastShot = Date.now();
					enemyCarr.push(Ncar);
				}

				// ============================================BOX MAKING==============================
				for (var i = 0; i < myWorld.noOfBox(); i++) {

					myWorld.setWorldBoxPosition();
					createBoxes(myWorld.myBoxesPosition.position.x, myWorld.myBoxesPosition.position.y, myWorld.myBoxesPosition.position.z);

				}

				//======================================================================================
				// for (var j = 0; j < 4; j++) {

					// if (j == 0) {
						// xWidth = 5000;
						// zWidth = 20000;
						// xPos = 10000;
						// zPos = 0;
					// }
					// if (j == 1) {
						// xWidth = 20000;
						// zWidth = 5000;
						// xPos = 0;
						// zPos = 10000;
					// }
					// if (j == 2) {
						// xWidth = 5000;
						// zWidth = 20000;
						// xPos = -10000;
						// zPos = 0;
					// }
					// if (j == 3) {
						// xWidth = 20000;
						// zWidth = 5000;
						// xPos = 0;
						// zPos = -10000;
					// }

					// var materialArray = [];
					// materialArray.push(new THREE.MeshBasicMaterial({
						// map : THREE.ImageUtils.loadTexture('images/background.jpg')
					// }));
					// materialArray.push(new THREE.MeshBasicMaterial({
						// map : THREE.ImageUtils.loadTexture('images/background.jpg')
					// }));
					// materialArray.push(new THREE.MeshBasicMaterial({
						// map : THREE.ImageUtils.loadTexture('images/background.jpg')
					// }));
					// materialArray.push(new THREE.MeshBasicMaterial({
						// map : THREE.ImageUtils.loadTexture('images/background.jpg')
					// }));
					// materialArray.push(new THREE.MeshBasicMaterial({
						// map : THREE.ImageUtils.loadTexture('images/background.jpg')
					// }));
					// materialArray.push(new THREE.MeshBasicMaterial({
						// map : THREE.ImageUtils.loadTexture('images/background.jpg')
					// }));
					// var skyboxGeom = new THREE.CubeGeometry(xWidth, 5000, zWidth, 2, 2, 2, materialArray);
					// var skybox = new THREE.Mesh(skyboxGeom, new THREE.MeshFaceMaterial());
					// skybox.position.x = xPos;
					// skybox.position.y = 2500;
					// skybox.position.z = zPos;
					// skybox.flipSided = true;
					// skybox.side = THREE.BackSide;
					// scene.add(skybox);
				// }
				
			
				// sceneCube = new THREE.Scene();
				var r = "textures/cube/skybox/";
				var urls = [ r + "px.jpg", r + "nx.jpg",
							 r + "py.jpg", r + "ny.jpg",
							 r + "pz.jpg", r + "nz.jpg" ];

				var textureCube = THREE.ImageUtils.loadTextureCube( urls );
				textureCube.format = THREE.RGBFormat;
				
				var shader = THREE.ShaderUtils.lib[ "cube" ];
				shader.uniforms[ "tCube" ].value = textureCube;

				var material = new THREE.ShaderMaterial( {

					fragmentShader: shader.fragmentShader,
					vertexShader: shader.vertexShader,
					uniforms: shader.uniforms,
					depthWrite: false,
					side: THREE.BackSide

				} ),

				mesh = new THREE.Mesh( new THREE.CubeGeometry( 100000, 100000, 100000 ), material );
				mesh.rotation.x = -(Math.PI) / 2;
				mesh.rotation.z = -(Math.PI) / 2;
				// mesh.position.x = 10000;
				//mesh.position.z = zPos;
				scene.add( mesh );
				
				//load a car			 
//IMPORTANT: be sure to use ./ or it may not load the .bin correctly 
// new THREE.BinaryLoader().load('VeyronNoUv_bin.js', function(geometry) { 
    // var orange    = new THREE.MeshLambertMaterial( { color: 0x995500, opacity: 1.0, transparent: false } ); 
    // var mesh	= new THREE.Mesh( geometry, orange ); 
    // mesh.scale.x = mesh.scale.y = mesh.scale.z = 10; 
	// mesh.position.x = 1000;
    // scene.add( mesh ); 
    // carr = mesh; 
// });
 
				//====================================================================================

				// Lights

				var ambientLight = new THREE.AmbientLight(/*Math.random() * 0x10*/0xffffff);
				scene.add(ambientLight);

				var directionalLight = new THREE.SpotLight(/*Math.random() * 0xffffff*/0x1a4d06);
				directionalLight.position.x = -2000;
				directionalLight.position.y = 100;
				directionalLight.position.z = 6000;
				//directionalLight.position.normalize();
				directionalLight.castShadow = true;
				directionalLight.shadowCameraNear = 1000;
				directionalLight.shadowCameraFar = camera.far;
				directionalLight.shadowCameraFov = 200;
				directionalLight.shadowBias = -0.00125;
				directionalLight.shadowDarkness = .4;
				directionalLight.shadowMapWidth = 1024;
				directionalLight.shadowMapHeight = 1024;
				//directionalLight.shadowCameraVisible = true;
				scene.add(directionalLight);

				//renderer = new THREE.CanvasRenderer();
				renderer = new THREE.WebGLRenderer();

				renderer.setSize(window.innerWidth, window.innerHeight);

				container.appendChild(renderer.domElement);

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '30px';
				container.appendChild(stats.domElement);

				//keyboard
				keyboard = new THREEx.KeyboardState();

				window.addEventListener('resize', onWindowResize, false);

			}

			var bulletMaterial = new THREE.MeshBasicMaterial({
				color : 0x00FF00
			});
			var bulletGeo = new THREE.SphereGeometry(20, 20, 20);
			function createBullet(obj, obj2) {

				if (obj === undefined) {
					obj = localObject;
					obj2 = enemy;
				}

				var bullet = new THREE.Mesh(bulletGeo, bulletMaterial);
				bullet.position.set(obj.position.x, (obj.position.y + 15) * 0.8, obj.position.z);
				// var originPoint = bullet.position.clone();

				if (obj === localObject) {
					var vector = camera.position.clone();
					bullet.ray = new THREE.Ray(obj.position, vector.subSelf(obj.position).normalize());
				} else {
					var vector = obj2.position.clone();
					bullet.ray = new THREE.Ray(obj.position, vector.subSelf(obj.position).normalize());
				}

				bullet.owner = obj;

				bullets.push(bullet);
				scene.add(bullet);

				return bullet;

			}

			function onWindowResize() {

				camera.left = window.innerWidth / -2;
				camera.right = window.innerWidth / 2;
				camera.top = window.innerHeight / 2;
				camera.bottom = window.innerHeight / -2;

				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMapEnabled = true;

			}

			function collision(obj, obj2, index) {
				var originPoint = obj.position.clone();

				//clearText();

				for (var vertexIndex = 0; vertexIndex < obj.geometry.vertices.length; vertexIndex++) {

					var localVertex = obj.geometry.vertices[vertexIndex].clone();
					var globalVertex = obj.matrix.multiplyVector3(localVertex);

					var directionVector = globalVertex.subSelf(obj.position);

					var ray = new THREE.Ray(originPoint, directionVector.clone().normalize());

					var collisionResults = ray.intersectObjects(obj2);

					if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
						if (obj === car) {
							//speed = -10;
							speed = myWorld.CarMove("W", true);
							//scene.remove(car);
							// $('#health').html(myWorld.healthControl());
							// if (myWorld.healthControl() <= 0)
							// $('#health').html("Finished");
						} else if (obj != car) {

							// if(index == 0){
							// $('#enemyHealth1').html(myWorld.enemyHealthControl(index));
							// if (myWorld.enemyHealthControl() <= 0)
							// $('#enemyHealth1').html("Finished");
							// }
							// else if(index == 1){
							// $('#enemyHealth2').html(myWorld.enemyHealthControl(index));
							// if (myWorld.enemyHealthControl() <= 0)
							// $('#enemyHealth2').html("Finished");
							// }
							// else if(index == 2){
							// $('#enemyHealth3').html(myWorld.enemyHealthControl(index));
							// if (myWorld.enemyHealthControl() <= 0)
							// $('#enemyHealth3').html("Finished");
							// }

							Nspeed = myWorld.setEnemyCarSpeed(timer, true, index);
						}
					}

				}
			}

			function updateTime() {

				myWorld.updateWorldTime();
				timer = myWorld.worldTime.currentTime.getSeconds();

				// $('#time').html(timer + "s");

			}

			function animate(runAnim) {

				requestAnimationFrame(animate);

				collision(car, collidableMeshList);
				collision(car, enemyCarr);

				collision(car, boxArray);

				updateTime();

				render();
				stats.update();

			}

			function createBoxes(xPos, yPos, zPos) {
				var texture = new THREE.Texture();

				var loader = new THREE.ImageLoader();
				loader.addEventListener('load', function(event) {

					texture.image = event.content;
					texture.needsUpdate = true;

				});
				loader.load('obj/crate.gif');

				// model

				var loader = new THREE.OBJLoader();
				loader.addEventListener('load', function(event) {

					var object = event.content;

					for (var i = 0, l = object.children.length; i < l; i++) {

						object.children[i].material.map = texture;

					}
					object.scale.x = object.scale.y = object.scale.z = 200;
					object.position.x = xPos;
					object.position.y = yPos;
					object.position.z = zPos;
					//object.rotation.x = - (Math.PI) / 2;
					//objects.push(object);
					scene.add(object);

				});
				loader.load('obj/Crate Box/crate.obj');

				var boxGeometry = new THREE.CubeGeometry(190, 190, 190);
				var boxMaterial = new THREE.MeshLambertMaterial({
					color : 0x000000,
					//shading : THREE.FlatShading,
					overdraw : true,
					//map : texture
				});

				box = new THREE.Mesh(boxGeometry, boxMaterial);
				//myWorld.setWorldCar();
				box.position.x = xPos;
				box.position.y = yPos;
				box.position.z = zPos - 120;
				box.castShoadow = true;
				box.receiveShadow = true;
				collidableMeshList.push(box);
				box.material.wireframe = true;
				scene.add(box);
			}

			function createTrees(xPos, yPos, zPos) {
				var texture1 = new THREE.Texture();

				var loader = new THREE.ImageLoader();
				loader.addEventListener('load', function(event) {

					texture1.image = event.content;
					texture1.needsUpdate = true;

				});
				loader.load('obj/normal_L1010014.jpg');

				// model

				var loader = new THREE.OBJLoader();
				loader.addEventListener('load', function(event) {

					var object = event.content;

					for (var i = 0, l = object.children.length; i < l; i++) {

						object.children[i].material.map = texture1;

					}
					object.scale.x = object.scale.y = object.scale.z = 5;
					object.position.x = xPos;
					object.position.y = 0;
					object.position.z = zPos;
					object.rotation.x = -(Math.PI) / 2;
					//objects.push(object);
					scene.add(object);

				});
				loader.load('obj/Palm_Tree.obj');

				var texture = THREE.ImageUtils.loadTexture("obj/crate.gif");
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set(.5, .5);
				var boxGeometry = new THREE.CubeGeometry(30, 650, 30);
				var boxMaterial = new THREE.MeshLambertMaterial({
					// color : 0x5CD715,
					shading : THREE.FlatShading,
					overdraw : true,
					map : texture

				});

				box = new THREE.Mesh(boxGeometry, boxMaterial);

				box.position.x = xPos;
				box.position.y = 0;
				box.position.z = zPos;
				box.castShadow = true;
				box.transparent = true;
				collidableMeshList.push(box);
				//	box.material.wireframe = true;
				scene.add(box);

			}

			function distance(x1, y1, x2, y2) {

				var dis = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
				return dis;
			}

			function checkHit(bullet) {

				for (var i = collidableMeshList.length - 1; i >= 0; i--) {
					var collideMesh = collidableMeshList[i];
					var v = collideMesh.geometry.vertices[0];
					var c = collideMesh.position;
					var x = Math.abs(v.x), z = Math.abs(v.z);

					if (bullet.x < c.x + x && bullet.x > c.x - x && bullet.z < c.z + z && bullet.z > c.z - z) {

						return true;
					}
				}

				return false;
			}

			function render() {

				for (var j = enemyCarr.length - 1; j >= 0; j--) {

					enemy = enemyCarr[j];
					collision(enemy, collidableMeshList, j);
					collision(enemy, collidableMesh, j);

					var dist = distance(enemy.position.x, enemy.position.z, localObject.position.x, localObject.position.z);

					if (dist < 600 && Date.now() > enemy.lastShot + 750) {
						object = createBullet(enemy, localObject);
						enemy.lastShot = Date.now();
					}
					// console.log("dist "+ dist + "enemy " + enemy.position.x);
					// if(distance(enemy.position.x, enemy.position.z, localObject.position.x, localObject.position.z) < 700){

					// Nspeed = myWorld.setEnemyCarSpeed(timer, true, index);

					// }

					//scene.remove(enemy);
				}
				//scene.remove(car);
				var delta = cloc.getDelta();

				var bspeed = delta * 3000;
				var hit = false;
				for (var i = bullets.length - 1; i >= 0; i--) {
					var b = bullets[i];

					d = b.ray.direction;

					if (checkHit(b.position) === true) {
						hit = true;
						bullets.splice(i, 1);
						scene.remove(b);
					}

					if (checkHit(localObject.position) === true) {
						speed = myWorld.CarMove("W", true);
					}

					if (!hit && b.owner != localObject) {
						//b.rotation.x = Math.PI / 2;
						b.translateX(bspeed * (d.x));
						b.translateZ(bspeed * (d.z));

					}

					if (!hit && b.owner == localObject) {
						//b.rotation.x = Math.PI / 2;
						b.translateX(bspeed * -(d.x));
						b.translateZ(bspeed * -(d.z));

					}
					dist = distance(b.position.x, b.position.z, localObject.position.x, localObject.position.z);
					if (dist < 150 && b.owner != localObject) {
						$('#hurt').fadeIn(75);

						//speed = myWorld.CarMove("W", true);
						$('#health').html(myWorld.healthControl());
						if (myWorld.healthControl() <= 0) {
							runAnim = false;
							$(renderer.domElement).fadeOut();
							$('#hud').fadeOut();
							$('#intro').fadeIn();
							$('#intro').html('Game Over! Click to restart...');
							$('body').append('<div id="intro">Click to start</div>');
							$('#intro').css({
								width : 1366,
								height : 768
							}).one('click', function(e) {

								location = location;
							});
						}
						bullets.splice(i, 1);
						scene.remove(b);
						$('#hurt').fadeOut(350);

					}

					for (var j = enemyCarr.length - 1; j >= 0; j--) {

						enemy = enemyCarr[j];

						var dist = distance(enemy.position.x, enemy.position.z, b.position.x, b.position.z);

						if (dist < 150 && b.owner == localObject) {

							if (j == 0) {
								$('#enemyHealth1').html(myWorld.enemyHealthControl(j));
								if (myWorld.enemyHealthControl() <= 0) {
									$('#enemyHealth1').html("Finished");
									enemy.position.x = 15000;
									enemy.position.z = 15000;
									//scene.remove(enemy);

								}
							} else if (j == 1) {
								$('#enemyHealth2').html(myWorld.enemyHealthControl(j));

								if (myWorld.enemyHealthControl() <= 0) {
									$('#enemyHealth2').html("Finished");
									enemy.position.x = 15000;
									enemy.position.z = 15000;
									//scene.remove(enemy);

								}
							} else if (j == 2) {
								$('#enemyHealth3').html(myWorld.enemyHealthControl(j));
								if (myWorld.enemyHealthControl() <= 0) {
									$('#enemyHealth3').html("Finished");
									enemy.position.x = 15000;
									enemy.position.z = 15000;
									//scene.remove(enemy);

								}
							}
							bullets.splice(i, 1);
							scene.remove(b);
							//Nspeed = myWorld.setEnemyCarSpeed(timer, true, j);
						}

						//scene.remove(enemy);
					}

				}
				var rotationAngle = 0.05 * Math.abs(speed / 10);
				if (rotationAngle > 0.05)
					rotationAngle = 0.05;

				if (keyboard.pressed("A")) {
					localObject.rotation.z += rotationAngle;

					if (localObject.rotation.z > 6)
						localObject.rotation.z -= 6;
				}

				if (keyboard.pressed("D")) {
					localObject.rotation.z -= rotationAngle;
					if (localObject.rotation.z < 0)
						localObject.rotation.z = 6 + localObject.rotation.z;
				}
				if (keyboard.pressed("W")) {
					//speed += acceleration;

					speed = myWorld.CarMove("W", false);

					$('#speed').html(speed);

				}
				if (keyboard.pressed("S")) {

					speed = myWorld.CarMove("S", false);
					$('#speed').html(speed);

				}
				if (keyboard.pressed("up")) {
					cameraYPos += cameraYPos > 500 ? 0 : 10;
				}
				if (keyboard.pressed("down")) {
					cameraYPos -= cameraYPos <= 0 ? 0 : 10;
				}

				if (!keyboard.pressed("W") && !keyboard.pressed("S")) {

					myWorld.CarMove("F", false);

					$('#speed').html(speed);

				}

				// ==================================NEW ENEMY CAR=================================================s

				// update car position
				var phaseX = 1;
				var phaseY = 1;
				//var eR = myWorld.myCar.rotation.y;
				var eR = localObject.rotation.x + localObject.rotation.z;
				car.rotation.y = localObject.rotation.x + localObject.rotation.z;
				//		wheel.rotation.y = localObject.rotation.x + localObject.rotation.z;
				var computedX = (localObject.position.x + ((speed * Math.cos(eR)) * phaseX));
				var computedZ = (localObject.position.z - ((speed * Math.sin(eR)) * phaseY));

				// var computedX = (myWorld.myCar.position.x + ((myWorld.myCar.speed++ * Math.cos(eR)) * phaseX));
				// var computedZ = (myWorld.myCar.position.z - ((myWorld.myCar.speed++ * Math.sin(eR)) * phaseY));

				localObject.position.x = computedX;
				localObject.position.z = computedZ;
				car.position.x = computedX;
				car.position.z = computedZ;
				// wheel.position.x = computedX +100;
				// wheel.position.z = computedZ +100;

				// =========================NEW ENEMY CAR========================================
				for (var k = 0; k < myWorld.noOfEnemies(); k++) {
					enemyCarr[k].rotation.y = myWorld.setEnemyCarRotation(timer, enemyCarr[k].rotation.y, k);

					var eRN = enemyCarr[k].rotation.y;

					enemyCarr[k].position.x = myWorld.setEnemyCarNewPositionX(myWorld.setEnemyCarSpeed(timer, false, k), eRN, enemyCarr[k].position.x, k);
					enemyCarr[k].position.z = myWorld.setEnemyCarNewPositionZ(myWorld.setEnemyCarSpeed(timer, false, k), eRN, enemyCarr[k].position.z, k);

					if (k > myWorld.noOfEnemies())
						k = 1;

				}

				//=======================old car speed==================================

				if (speed > 0)
					speed = speed - speedDamping;
				else
					speed = 0;

				if (speed > maxSpeed)
					speed = maxSpeed;

				// camera.position.x = Math.cos(timer) * 200;
				// camera.position.z = Math.sin(timer) * 200;

				camera.position.x = localObject.position.x - (Math.cos(eR) * 500 );
				camera.position.z = localObject.position.z + (Math.sin(eR) * 500 );

				// new car camera==============

				// camera.position.x = Ncar.position.x - (Math.cos(eRN) * 500 );
				// camera.position.z = Ncar.position.z + (Math.sin(eRN) * 500 );

				camera.position.y = cameraYPos;
				camera.lookAt(localObject.position);
				//camera.lookAt(Ncar.position);
				renderer.shadowMapEnabled = true;
				renderer.render(scene, camera);

			}

		</script>

	</body>
</html>
