<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Crime Racer</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <canvas id="radar" width="200" height="200"></canvas>
    <canvas id="speedometer" width="150" height="100"></canvas>
    <canvas id="health11" width="150" height="20"></canvas>
    <canvas id="bombs" width = "100" height="100"></canvas>
	<canvas id="mines" width = "100" height="100"></canvas>
	<canvas id="bullet" width = "100" height="100"></canvas>

    <style>
        body {

            font-family: Monospace;
            background-color: #50dee7;
            margin: 0px auto;
            overflow: hidden;
            background-image: url('images/Capture.jpg');
            color: black;
            position: absolute;
        }

        #hud {
            top: 10px;
            margin-right: 40px;
            position: absolute;
            right: 10px;
            z-index: 100;
            background-color: #05580C;
            opacity: .5;
            border: 1px soild black;
            color: white;
            text-shadow: 0 0 30px #c61a1a;
            font-size: 22px;
            font-style: "Comic Sans MS", cursive, sans-serif;
            font-weight: bold;
            padding-right: 5px;
            padding-left: 5px;
        }
        #intro {
            background-color: #000000;
            color: #FFFFFF;
            cursor: pointer;
            font-size: 32px;
            opacity: 0.7;
            padding: 120px;
            text-align: center;
            z-index: 1001;
        }
        #hurt {
            background-color: red;
            display: none;
            left: 10;
            opacity: 0.15;
            pointer-events: none;
            position: absolute;
            top: 0;
            z-index: 1002;
        }
        #radar {
            background-color: #EEEEEE;
            border: 1px solid black;
            bottom: 10px;
            left: 10px;
            position: absolute;
            z-index: 100;
            opacity: .5;
        }
        #speedometer {
            background-color: #EEEEEE;
            border: 1px solid black;
            bottom: 550px;
            left: 700px;
            position: absolute;
            z-index: 100;
            opacity: .5;
        }
        #health11 {
            background-color: #EEEEEE;
            border: 1px solid black;
            bottom: 520px;
            left: 700px;
            position: absolute;
            z-index: 100;
            opacity: .5;
        }
        #bombs{
            background-color: #EEEEEE;
            border: 1px solid black;
            bottom: 550px;
            left: 550px;
            position: absolute;
            z-index: 100;
            opacity: .5;
        }
		#bullet{
            background-color: #EEEEEE;
            border: 1px solid black;
            bottom: 550px;
            left: 400px;
            position: absolute;
            z-index: 100;
            opacity: .5;
        }
		#mines{
            background-color: #EEEEEE;
            border: 1px solid black;
            bottom: 550px;
            left: 250px;
            position: absolute;
            z-index: 100;
            opacity: .5;
        }
        #myCanvas {
            background-color: #EEEEEE;
            border: 1px solid black;
            bottom: 450px;
            left: 700px;
            position: absolute;
            z-index: 100;

        }
		
        #paused{
            top: 190px;
            margin-right: 40px;
            position: absolute;
            right: 550px;
            z-index: 100;
            background-color: #05580C;
            opacity: .5;
            border: 1px soild black;
            color: white;
            text-shadow: 0 0 30px #c61a1a;
            font-size: 40px;
            font-style: "Comic Sans MS", cursive, sans-serif;
            font-weight: bold;
            padding-right: 5px;
            padding-left: 5px;

        }
		#next{
            top: 190px;
            margin-right: 40px;
            position: absolute;
            right: 550px;
            z-index: 100;
            background-color: #05580C;
            opacity: .5;
            border: 1px soild black;
            color: white;
            text-shadow: 0 0 30px #c61a1a;
            font-size: 40px;
            font-style: "Comic Sans MS", cursive, sans-serif;
            font-weight: bold;
            padding-right: 5px;
            padding-left: 5px;

        }
        #start{
            top: 190px;
            margin-right: 40px;
            position: absolute;
            right: 550px;
            z-index: 100;
            background-color: #05580C;
            opacity: .5;
            border: 1px soild black;
            color: white;
            text-shadow: 0 0 30px #c61a1a;
            font-size: 40px;
            font-style: "Comic Sans MS", cursive, sans-serif;
            font-weight: bold;
            padding-right: 5px;
            padding-left: 5px;

        }
        #paused.blinking{
            color: black;
        }
    </style>
</head>

</div>
<body>

    <script src="threejs/three/jquery-1.7.2.min.js"></script>
    <script src="threejs/three/three.min.js"></script>
    <script src="threejs/three/ImprovedNoise.js"></script>
    <script src="threejs/three/threex.sparks.js"></script>
    <script src="threejs/three/Sparks.js"></script>
    <script src="threejs/three/Tween.js"></script>
    <script src="threejs/three/ShaderExtras.js"></script>
    <script src="threejs/three/CollisionUtils.js"></script>
    <script src="threejs/three/Collisions.js"></script>
    <script src="threejs/three/Stats.js"></script>
    <script src="extras/THREEx.KeyboardState.js"></script>
    <script src="objects/car.js"></script>
    <script src="objects/checck.js"></script>
    <script src="objects/wall.js"></script>
    <script src="loader/MTLLoader.js"></script>
    <script src="loader/OBJLoader.js"></script>
    <script src="loader/ColladaLoader.js"></script>
    <script src="loader/Car.js"></script>
    <script src="loader/OBJMTLLoader.js"></script>
    <script src="objects/world2.js"></script>
    <script src="objects/tree.js"></script>
    <script src="objects/boxes.js"></script>

    <script src="objects/time.js"></script>
    <script src="objects/enemyCar.js"></script>

    <script id="vertexShaderAtmosphere" type="x-shader/x-vertex">
        varying vec3 vNormal;
        void main() 
        {
        vNormal = normalize( normalMatrix * normal );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    </script>

    <!-- fragment shader a.k.a. pixel shader -->
    <script id="fragmentShaderAtmosphere" type="x-shader/x-vertex"> 
        uniform float c;
        uniform float p;
        varying vec3 vNormal;
        void main() 
        {
	float intensity = pow( c - dot( vNormal, vec3( 0.0, 0.0, 1.0 ) ), p ); 
	gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 ) * intensity;
        }
    </script>


    <script>
        var container, stats;
        var camera, scene, renderer;
        var sphere;
        var car;
        var Ncar;
		
        var enemyCarr = [];
        var speed = 0;
        var Nspeed = 0;
        var acceleration = 3;
        var speedDamping = 1;
        var maxSpeed = 200;
        var speedGain = 70;
        var cameraYPos = 250;
        var mycar;
        var eneCar;
        var object;
        var carHit = false;
        var box;
        var textu;
        var myWorld = new CrimeRacer.World;
		var nextLevel = myWorld.noOfEnemies();
        var distance1 = 0;
        var collideMesh;
        var collidableMeshList = [];
        var collidableMesh = [];
        var bullets = [];
        var localObject;
        var cloc = new THREE.Clock();
        var index = 0;
        var enemy;
        var refrencePoint = [];
        var point;
        var hitCount = 0;
        var checkObj;
        var wall;
        var timer = myWorld.worldTime.currentTime.getSeconds();
        var XPath, YPath, ZPath;
        var Ccar;
        var te = 500;
        var tree;
        var treesPositionX = [];
        var treesPositionZ = [];
        var loader2 = new THREE.ColladaLoader();
        var bulletOfCar;
        var wheel;
        var locatio = 0;
        var boxArray = [];
        var carHeight = 0;
        var box;
        var countEnemyMove = 0;
        var runAnim = true;
        var xWidth = 0;
        var zWidth = 0;
        var xPos = 0;
        var zPos = 0;
        var carr;
        var bulletObj;
        var treeIndex = 0;
        var wallIndex = 0;
        var wallPositionX = [];
        var wallPositionZ = [];
        var slopeGround;
        var worldWidth = 256, worldDepth = 256, worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
        var ground;
        var newCar = new THREE.Car();
        var mines;
        var minesList = [];
        var bombList = [];
        // init();
        var pos = 150;
        var particles = [];
        // var enemy1;
        // var enemy2;
        // var enemy3;
        var enemyModels = [];
        var cylinder;
        var particleArray = [];
        var animatee = true;
        var leftPoint = [];
        var rightPoint = [];
        var checkDirection = [];
        var check;
        var Cuniforms;
        var cameras;
        var cameraArray = [];
        var move = 'R';
        var hitDirection = false;
        var hitObj;
        var indexDir = 0;
        var ball;
        var arrayTrue = [];
        var text;
        var text2;
        var boomer;
        var boomer1;
        //var boxContainer = [];
        var pointLeft;
        var boxSimpleArray = [];
        var boxSimpleArray2 = [];
        var healthcube;
		var bombCube;
		var mineCube;
        var lastHealthPickup = 0;
        var carTexture;
        var changeWeapon = "redBullet";

        // animate();
		
        var Sound = function ( sources, radius, volume ) {

            var audio = document.createElement( 'audio' );

            for ( var i = 0; i < sources.length; i ++ ) {

                var source = document.createElement( 'source' );
                source.src = sources[ i ];

                audio.appendChild( source );

            }

            this.position = new THREE.Vector3();

            this.play = function () {

                audio.play();

            }

            this.update = function ( camera ) {

                var distance = this.position.distanceTo( camera.position );

                if ( distance <= radius ) {

                    audio.volume = volume * ( 1 - distance / radius );

                } else {

                    audio.volume = 0;

                }

            }

        }
		
		function startMenu(){
		animatee = false;
		// $('body').append('<button id="start">Start</button>');
		// $('#start').click(function(){animatee = true; return true;});
		
		}
		// animatee = false;
		// $('body').append('<button id="start">Start</button>');
		// animatee = $('#start').click(function(){animatee = true; return true;});
        loader2.load('objc/us/us_police_car.dae', function colladaReady(collada) {
            localObject = collada.scene;

            localObject.scale.x = localObject.scale.y = localObject.scale.z = 2;
            localObject.updateMatrix();
            localObject.position.x = 0;
            localObject.position.y = 0;
            localObject.position.z = 0;

            localObject.rotation.x = -(Math.PI / 2);

            localObject.rotation.z = (Math.PI / 2);

		
            init();
		
            animate();
				


        });
		// startMenu();
			
        function gameMenu(){
            animatee = false;
			
			
            $('body').append('<button id="paused">Game Over</button>');
			$('#paused').click(function(){location = location});
		}
            // var el = $('#paused');
            // setInterval(function() {
            // el.toggleClass('blinking');
            // }, 3000);
			
        
		
		function nextround(){
		animatee = false;
		$('body').append('<button id="next">Next Level</button>');
		$('#next').click(function(){location = "CrimeRacer1.html"});
		}
        function gameStart(){
            animatee = true;
        }
        function hitTerrain() {

            var vector = ground.position.clone();
            var rc = new THREE.Ray(localObject.poition, vector.subSelf(localObject.position).normalize);
            var results = rc.intersectObject(ground);
            if (results[0])
                alert('hit at ' + results[0].point);
        }

        function init() {

            //hitTerrain();
            container = document.createElement('div');
            document.body.appendChild(container);

            var info = document.createElement('div');

            container.appendChild(info);

            //camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -2000, 1000);
            camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 2, 100000);

            camera.position.set(-1000, 0, 0);
				
            for(var i = 0; i < myWorld.noOfEnemies(); i++){
				
                cameras = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 2, 100000);

                cameras.position.set(-1000, 0, 0);
				
                cameraArray.push(cameras);
            }

            scene = new THREE.Scene();
            //scene.fog = new THREE.FogExp2(0xD6F1FF, 0.0003);
            

            data = generateHeight(worldWidth, worldDepth);
            var texture = THREE.ImageUtils.loadTexture("images/1.jpg");
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10);

            groundBasic = new THREE.MeshLambertMaterial({
                color : 0x473e34,
                map : texture
            });
            groundBasic.color.setHSV(0.1, 0.45, 0.995);

            ground = new THREE.Mesh(new THREE.PlaneGeometry(15000, 15000, worldWidth - 1, worldDepth - 1), groundBasic);
            
            //console.log(ground.geometry.vertices.length);

            //	ground.position.x = 10000;
            ground.position.y = 0;
            ground.rotation.x = (-Math.PI / 2);
            ground.rotation.z = (-Math.PI / 2);
            //ground.rotation.y = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.dynamic = true;
            //collidableMesh.push(ground);
            scene.add(ground);
			
				
            // base image texture for mesh
            var lavaTexture = new THREE.ImageUtils.loadTexture( 'images/blast.jpg');
            lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;
            // multiplier for distortion speed 
            var baseSpeed = 0.02;
            // number of times to repeat texture in each direction
            var repeatS = repeatT = 10;

            // texture used to generate "randomness", distort all other textures
            var noiseTexture = new THREE.ImageUtils.loadTexture( 'images/blast.jpg' );
            noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping;
            // magnitude of noise effect
            var noiseScale = 0.5;

            // texture to additively blend with base image texture
            var blendTexture = new THREE.ImageUtils.loadTexture( 'images/lava.jpg' );
            blendTexture.wrapS = blendTexture.wrapT = THREE.RepeatWrapping;
            // multiplier for distortion speed
            var blendSpeed = 0.01;
            // adjust lightness/darkness of blended texture
            var blendOffset = 0.25;

            // texture to determine normal displacement
            var bumpTexture = noiseTexture;
            bumpTexture.wrapS = bumpTexture.wrapT = THREE.RepeatWrapping;
            // multiplier for distortion speed 
            var bumpSpeed   = 0.15;
            // magnitude of normal displacement
            var bumpScale   = 40.0;

            // use "this." to create global object
            this.customUniforms = {
                baseTexture:  { type: "t", value: lavaTexture },
                baseSpeed:    { type: "f", value: baseSpeed },
                repeatS:      { type: "f", value: repeatS },
                repeatT:      { type: "f", value: repeatT },
                noiseTexture: { type: "t", value: noiseTexture },
                noiseScale:   { type: "f", value: noiseScale },
                blendTexture: { type: "t", value: blendTexture },
                blendSpeed:   { type: "f", value: blendSpeed },
                blendOffset:  { type: "f", value: blendOffset },
                bumpTexture:  { type: "t", value: bumpTexture },
                bumpSpeed:    { type: "f", value: bumpSpeed },
                bumpScale:    { type: "f", value: bumpScale },
                alpha:        { type: "f", value: 1.0 },
                time:         { type: "f", value: 1.0 }
            };

            // create custom material from the shader code above
            //   that is within specially labeled script tags
            var customMaterialAtmosphere = new THREE.ShaderMaterial( 
            {
                uniforms:       
                    { 
                    "c":   { type: "f", value: 0.5 },
                    "p":   { type: "f", value: 4.0 }
                },
                vertexShader:   document.getElementById( 'vertexShaderAtmosphere'   ).textContent,
                fragmentShader: document.getElementById( 'fragmentShaderAtmosphere' ).textContent
            }   );

            // var sphereGeo = new THREE.SphereGeometry(100, 32, 16);
            // text2 = THREE.ImageUtils.loadTexture( 'images/smoke2.jpg' );
            // //var moonTexture = THREE.ImageUtils.loadTexture( 'images/moon.jpg' );
            // var moonMaterial = new THREE.MeshBasicMaterial( { map: text2 } );
            // var moon = new THREE.Mesh(sphereGeo, moonMaterial);
            // // scene.add(moon);
			
            carTexture = new THREE.ImageUtils.loadTexture( 'images/texture0.jpg' );
			
            var texture = THREE.ImageUtils.loadTexture("images/particle.png");
			
			$(document).keypress(function(e)
{
    var s = String.fromCharCode(e.which);
    if (s.match(/[a-zA-Z\.]/) == 'c'){
		if(changeWeapon === "pinkBullet")
        changeWeapon = "redBullet";
		else if(changeWeapon === "redBullet")
		changeWeapon = "pinkBullet";
		}
		
});
            
				
            $(document).click(function(e) {
                e.preventDefault
                if (e.which === 1) {// Left click only
                    for (var j = enemyCarr.length - 1; j >= 0; j--) {
                        enemy = enemyCarr[j];
                        var dist = distance(enemy.position.x, enemy.position.z, localObject.position.x, localObject.position.z);
                        if (dist < 3000) {
						console.log(changeWeapon);
                            if(changeWeapon === "redBullet"){
                                object = createBullet();
                                myWorld.reduceBulletsOfPlayer();
                            }
                            else if(changeWeapon === "pinkBullet"  && myWorld.getBombOfPlayer() > 0){
                                object = createMines();
								myWorld.reduceBombOfPlayer();
								}
							
                            var sound2 = new Sound( [ 'audios/bulletFire.mp3'], 275, 1 );
                            sound2.play();
                        }
                        
                    }
                }

            });
				
            // $("body").on("keypress", function (e) {
                // if(!animatee) {
                    // // animatee = true;
                    // // animate(runAnim);
                    // // $('div').remove('#paused');
                    // location = location;
                // }
            // });
            // if (keyboard.pressed("E")) {
            // gameStart();

            // }
            
            // Set up "hurt" flash
            $('body').append('<div id="hurt"></div>');
            $('#hurt').css({
                width : 1600,
                height : 768
            });
            //$('#intro').css({width: 1366, height: 768});

            // Box

            // ========================TREE MAKING============================
            var texture = THREE.ImageUtils.loadTexture("images/wooden.jpg");
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(.5, .5);
            var boxGeometry = new THREE.CubeGeometry(70, 650, 70);
            var boxMaterial = new THREE.MeshLambertMaterial({
                // color : 0x5CD715,
                shading : THREE.FlatShading,
                overdraw : true,
                map : texture

            });
            for (var k = 0; k < myWorld.noOfTreeSides(); k++) {
                for (var l = 0; l <= myWorld.noOfTress(); l++) {
                    // box = new THREE.Mesh(boxGeometry, boxMaterial);

                    myWorld.setWorldTreePosition(k);

                    createTrees(myWorld.myTreePosition.position.x, myWorld.myTreePosition.position.y, myWorld.myTreePosition.position.z);
                }
            }

            scene.add(localObject);
			// var darkMaterial = new THREE.MeshBasicMaterial( { color: 0xffffcc } );
	// var wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } ); 
	// var multiMaterial = [ darkMaterial, wireframeMaterial ];
	// var shape = THREE.SceneUtils.createMultiMaterialObject( 
		// // radiusAtTop, radiusAtBottom, height, segmentsAroundRadius, segmentsAlongHeight,
		// new THREE.CylinderGeometry( 30, 30, 10, 20, 4 ), 
		// multiMaterial );
	// shape.position.set(-200, 50, -100);
	// scene.add( shape );
            //createMines(0,0,0);
            //createMissiles();
            // makeParticles();
            // ========================wall=================================
            var texture = THREE.ImageUtils.loadTexture("images/stone2.jpg");
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            var boxGeometry = new THREE.CubeGeometry(100, 500, 100);
            var boxMaterial = new THREE.MeshLambertMaterial({
                color : 0x8A5719,
                shading : THREE.FlatShading,
                overdraw : true,
                map : texture

            });
            for (var k = 1; k <= myWorld.noOfWallSide(); k++) {

                for (var i = 0; i < myWorld.noOfBlockPerBoundryWall(); i++) {

                    box = new THREE.Mesh(boxGeometry, boxMaterial);
                    scene.add(box);
                    collidableMeshList.push(box);
                    myWorld.setWallPosition(k);
                    box.position.x = myWorld.myWall.position.x;
                    box.position.y = myWorld.myWall.position.y;
                    box.position.z = myWorld.myWall.position.z;
                    // wallPositionX[wallInddex] = myWorld.myWall.position.x;
                    // wallPositionZ[wallIndex] = myWorld.myWall.position.z;
                    wallIndex++;
                    box.castShadow = true;
                    box.receiveShadow = true;

                }
            }
			
			

            //slope();

            //var sphere = new THREE.Mesh( new THREE.SphereGeometry(100,16,12),new THREE.MeshLambertMaterial( { color: 0x2D303D, wireframe: false, shading: THREE.FlatShading } ));
            // var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(100, 100, 200, 16, 4, false ),new THREE.MeshLambertMaterial( { color: 0x2D303D, wireframe: false, shading: THREE.FlatShading } ));
            // cylinder.position.y = -100;
            // scene.add(sphere);
            //scene.add(cylinder);
            var texture = THREE.ImageUtils.loadTexture("images/car.jpg");
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(.5, .5);

            var carGeometry = new THREE.CubeGeometry(400, 10, 150);
            var carMaterial = new THREE.MeshLambertMaterial({
                color : 0x000000,
                //shading : THREE.FlatShading,
                overdraw : true,
                map : texture
            });

            car = new THREE.Mesh(carGeometry, carMaterial);
            myWorld.setWorldCar();
            car.position.x = localObject.position.x + 10;
            car.position.y = localObject.position.y + 10;
            car.position.z = localObject.position.z;
            car.castShoadow = true;
            car.receiveShadow = true;
            collidableMesh.push(car);
            car.material.wireframe = true;
            scene.add(car);

            createEnemies();
            text = createEnemies2();
			
            text2 = createBoxes2(0,0,0);
            boomer1 = new TextureAnimator( text2, 4, 4, 16, 55 );
			
            boomer = new TextureAnimator( text, 4, 4, 16, 55 );
			
            healthcube = new THREE.Mesh(
            new THREE.CubeGeometry(190, 190, 190),
            new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('images/health.png')})
        );
            healthcube.position.set(5000, 150, -5000);
            scene.add(healthcube);
			
			bombCube = new THREE.Mesh(
            new THREE.CubeGeometry(190, 190, 190),
            new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('images/bomb2.jpg')})
        );
            bombCube.position.set(5000, 150, 5000);
            scene.add(bombCube);
			
			mineCube = new THREE.Mesh(
            new THREE.CubeGeometry(190, 190, 190),
            new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('images/mineSet.jpg')})
        );
            mineCube.position.set(-5000, 150, -5000);
            scene.add(mineCube);
            // ============================================BOX MAKING==============================
            for (var i = 0; i < myWorld.noOfBox(); i++) {

                myWorld.setWorldBoxPosition();
                createBoxes(myWorld.myBoxesPosition.position.x, myWorld.myBoxesPosition.position.y, myWorld.myBoxesPosition.position.z);
				
				

            }

            //======================================================================================
			  
            // sceneCube = new THREE.Scene();
            var r = "textures/cube/skybox/";
            var urls = [r + "px.jpg", r + "nx.jpg", r + "py.jpg", r + "ny.jpg", r + "pz.jpg", r + "nz.jpg"];

            var textureCube = THREE.ImageUtils.loadTextureCube(urls);
            textureCube.format = THREE.RGBFormat;

            var shader = THREE.ShaderUtils.lib["cube"];
            shader.uniforms["tCube"].value = textureCube;

            var material = new THREE.ShaderMaterial({

                fragmentShader : shader.fragmentShader,
                vertexShader : shader.vertexShader,
                uniforms : shader.uniforms,
                depthWrite : false,
                side : THREE.BackSide

            }), mesh = new THREE.Mesh(new THREE.CubeGeometry(100000, 100000, 100000), material);
            mesh.rotation.x = -(Math.PI) / 2;
            mesh.rotation.z = -(Math.PI) / 2;
            scene.add(mesh);
			
            // var skyBoxGeometry = new THREE.CubeGeometry( 20000, 20000, 20000 );
            // var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
            // var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
            // scene.add(skyBox);

            //====================================================================================

            // Lights

            var ambientLight = new THREE.AmbientLight(/*Math.random() * 0x10*/0xffffff);
            scene.add(ambientLight);

            var directionalLight = new THREE.SpotLight(/*Math.random() * 0xffffff*/0x1a4d06);
            directionalLight.position.x = -2000;
            directionalLight.position.y = 100;
            directionalLight.position.z = 6000;
            //directionalLight.position.normalize();
            directionalLight.castShadow = true;
            directionalLight.shadowCameraNear = 1000;
            directionalLight.shadowCameraFar = camera.far;
            directionalLight.shadowCameraFov = 200;
            directionalLight.shadowBias = -0.00125;
            directionalLight.shadowDarkness = .4;
            directionalLight.shadowMapWidth = 1024;
            directionalLight.shadowMapHeight = 1024;
            //directionalLight.shadowCameraVisible = true;
            scene.add(directionalLight);

            //renderer = new THREE.CanvasRenderer();
            renderer = new THREE.WebGLRenderer();

            renderer.setSize(window.innerWidth, window.innerHeight);

            container.appendChild(renderer.domElement);

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '30px';
            container.appendChild(stats.domElement);

            //keyboard
            keyboard = new THREEx.KeyboardState();

            window.addEventListener('resize', onWindowResize, false);

        }
		
        // var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(10, 0, 150, 50, 50, false), new THREE.MeshNormalMaterial());
        // cylinder.overdraw = true;
        // cylinder.position.x = 500;
        // cylinder.position.y = 20;
        // cylinder.position.z = 500;
        // // cylinder.rotation = enemy.rotation.x + enemy.rotation.z;
				
        // scene.add(cylinder);

        var texture = THREE.ImageUtils.loadTexture("images/peace.png");
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(1, 1);

        var bulletMaterial = new THREE.MeshBasicMaterial({
            color : 0xFF0000,
            //map : texture
        });
        var bulletGeo = new THREE.CubeGeometry(20, 20, 20);
        function createBullet(obj, obj2) {

            if (obj === undefined) {
                obj = localObject;
                obj2 = enemy;
            }
				
            var bullet = new THREE.Mesh(bulletGeo, bulletMaterial);
            bullet.position.set(obj.position.x, (obj.position.y + 15) * 0.8, obj.position.z);
            // var originPoint = bullet.position.clone();

            if (obj === localObject) {
                var vector = camera.position.clone();
                bullet.ray = new THREE.Ray(obj.position, vector.subSelf(obj.position).normalize());
            } else {
                var vector = obj2.position.clone();
                bullet.ray = new THREE.Ray(obj.position, vector.subSelf(obj.position).normalize());
            }

            bullet.owner = obj;
				
				
				
            //cylinder.rotation.z =  0;
            bullets.push(bullet);
            scene.add(bullet);
            //createBulletObj();
            return bullet;

        }

        function generateHeight(width, height) {

            var size = width * height, data = new Float32Array(size), perlin = new ImprovedNoise(), quality = 1, z = Math.random() * 100;

            for (var i = 0; i < size; i++) {

                data[i] = 0

            }

            for (var j = 0; j < 4; j++) {

                for (var i = 0; i < size; i++) {

                    var x = i % width, y = ~~(i / width );
                    data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.75);

                }

                quality *= 5;

            }

            return data;

        }
        function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) 
        {	
            // note: texture passed by reference, will be updated by the update function.
		
            this.tilesHorizontal = tilesHoriz;
            this.tilesVertical = tilesVert;
            // how many images does this spritesheet contain?
            //  usually equals tilesHoriz * tilesVert, but not necessarily,
            //  if there at blank tiles at the bottom of the spritesheet. 
            this.numberOfTiles = numTiles;
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
            texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );

            // how long should each image be displayed?
            this.tileDisplayDuration = tileDispDuration;

            // how long has the current image been displayed?
            this.currentDisplayTime = 0;

            // which image is currently being displayed?
            this.currentTile = 0;
		
            this.update = function( milliSec )
            {
                this.currentDisplayTime += milliSec;
                while (this.currentDisplayTime > this.tileDisplayDuration)
                {
                    this.currentDisplayTime -= this.tileDisplayDuration;
                    this.currentTile++;
                    if (this.currentTile == this.numberOfTiles)
                        this.currentTile = 0;
                    var currentColumn = this.currentTile % this.tilesHorizontal;
                    texture.offset.x = currentColumn / this.tilesHorizontal;
                    var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
                    texture.offset.y = currentRow / this.tilesVertical;
                }
            };
        }
        function onWindowResize() {

            camera.left = window.innerWidth / -2;
            camera.right = window.innerWidth / 2;
            camera.top = window.innerHeight / 2;
            camera.bottom = window.innerHeight / -2;

            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMapEnabled = true;

        }
			
        var checkMaterial = new THREE.MeshBasicMaterial({
            color : 0xFF00FF,
            //map : texture
        });
        
        function getDirection(obj, obj2){
            var checkGeo;
            if (obj === undefined) {
                obj = localObject;
                obj2 = enemy;
            }
				
            if(obj === localObject)
                checkGeo = new THREE.CubeGeometry(50, 50, 50);
            else
                checkGeo = new THREE.CubeGeometry(2, 2, 2);

            var bullet = new THREE.Mesh(checkGeo, checkMaterial);
            bullet.position.set(obj.position.x, (obj.position.y + 15) * 0.8, obj.position.z);
            // var originPoint = bullet.position.clone();

            if (obj === localObject) {
				
                var vector = camera.position.clone();
                bullet.ray = new THREE.Ray(obj.position, vector.subSelf(obj.position).normalize());
            } else {
                var vector = obj2.position.clone();
                bullet.ray = new THREE.Ray(obj.position, vector.subSelf(obj.position).normalize());
            }

            bullet.owner = obj;
				
				
				
            //cylinder.rotation.z =  0;
            checkDirection.push(bullet);
            scene.add(bullet);
            //createBulletObj();
            return bullet;
				
				
				
        }

        function collision(obj, obj2, index) {
            var originPoint = obj.position.clone();
            //console.log('point ; ' + originPoint);
            //clearText();

            for (var vertexIndex = 0; vertexIndex < obj.geometry.vertices.length; vertexIndex++) {

                var localVertex = obj.geometry.vertices[vertexIndex].clone();
                var globalVertex = obj.matrix.multiplyVector3(localVertex);

                var directionVector = globalVertex.subSelf(obj.position);

                var ray = new THREE.Ray(originPoint, directionVector.clone().normalize());

                var collisionResults = ray.intersectObjects(obj2);

                if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
                    
                    if (obj === car) {
                        //speed = -10;
                        var col = new THREE.Clock();

                        speed = myWorld.CarMove("W", true);
                        return true;
                    } else if (obj != car) {

                        Nspeed = myWorld.setEnemyCarSpeed(timer, true, index);
                    }
					
                }

            }
        }
		
        function continouseCollision(obj, obj2) {
            var originPoint = obj.position.clone();
            //console.log('point ; ' + originPoint);
            //clearText();

            for (var vertexIndex = 0; vertexIndex < obj.geometry.vertices.length; vertexIndex++) {

                var localVertex = obj.geometry.vertices[vertexIndex].clone();
                var globalVertex = obj.matrix.multiplyVector3(localVertex);

                var directionVector = globalVertex.subSelf(obj.position);

                var ray = new THREE.Ray(originPoint, directionVector.clone().normalize());

                var collisionResults = ray.intersectObjects(obj2);

                if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
                    return collisionResults[0].Object;
					
                }

            }
        }

        function updateTime() {

            myWorld.updateWorldTime();
            timer = myWorld.worldTime.currentTime.getSeconds();

            // $('#time').html(timer + "s");

        }
        var setMaterial = function(node, material) {
            node.material = material;
            if (node.children) {
                for (var i = 0; i < node.children.length; i++) {
                    setMaterial(node.children[i], material);
                }
            }
        }

        function speedDraw() {

            var Canvas = document.getElementById('speedometer');
            var ctx = Canvas.getContext('2d');

            var imageObj = new Image();

            imageObj.onload = function() {
                ctx.drawImage(imageObj, 0, 0);
            };
            imageObj.src = 'images/speedometer.jpg';
				

            var speed2 = speed + 3;
            if (speed2 < 0)
                speed2 = 0;

            ctx.beginPath();
            ctx.moveTo(70, 100);
            ctx.lineTo(speed, -(speed - speedGain - 25));
            //console.log("speed in speedometer: " + speed);
            ctx.stroke();
				

        }
        function bombDraw(pMines){
            var Canvas = document.getElementById('bombs');
            var ctx = Canvas.getContext('2d');
            // ctx.clearRect(0, 0, 100, 100);
            // ctx.save();
if(changeWeapon === "redBullet")
			ctx.globalAlpha=.2;	
else
			ctx.globalAlpha=1;	
			 var imageObj = new Image();

            imageObj.onload = function() {
                ctx.drawImage(imageObj, 0, 0);
            };
            imageObj.src = 'images/bomb.png';	
			// ctx.clearRect(0, 0, 100, 100);
            // ctx.save();		
            // ctx.clearRect(0, 0, 150, 20);
            // ctx.save();
            
                // ctx.fillStyle="green";
            
				
            // ctx.fillRect(0,0,pMines * 10,100);
				
            // // ctx.fill();
				
				ctx.clearRect(0, 0, 30, 30);
            ctx.save();
			
            ctx.strokeStyle = "#330000";
            ctx.font = '24px CURSIVE';
            ctx.textBaseline = 'hanging';
            ctx.strokeText(pMines, 0, 0);
            // ctx.restore();
			
			
        }
		function bulletDraw(pMines){
            var Canvas = document.getElementById('bullet');
            var ctx = Canvas.getContext('2d');
            // ctx.clearRect(0, 0, 100, 100);
            // ctx.save();
if(changeWeapon === "pinkBullet")
			ctx.globalAlpha=.2;	
else
			ctx.globalAlpha=1;	
			 var imageObj = new Image();

            imageObj.onload = function() {
                ctx.drawImage(imageObj, 0, 0);
            };
            imageObj.src = 'images/bullet11.png';	
			// ctx.clearRect(0, 0, 100, 100);
            // ctx.save();		
            // ctx.clearRect(0, 0, 150, 20);
            // ctx.save();
            
                // ctx.fillStyle="green";
            
				
            // ctx.fillRect(0,0,pMines * 10,100);
				
            // // ctx.fill();
				
				ctx.clearRect(0, 0, 45, 30);
            ctx.save();
			
            ctx.strokeStyle = "#330000";
            ctx.font = '24px CURSIVE';
            ctx.textBaseline = 'hanging';
            ctx.strokeText(pMines, 0, 0);
            // ctx.restore();
			
			
        }
		function mineDraw(pMines){
            var Canvas = document.getElementById('mines');
            var ctx = Canvas.getContext('2d');
           var imageObj = new Image();

            imageObj.onload = function() {
                ctx.drawImage(imageObj, 0, 0);
            };
            imageObj.src = 'images/miness.png';	
			// ctx.clearRect(0, 0, 100, 100);
            // ctx.save();		
            // ctx.clearRect(0, 0, 150, 20);
            // ctx.save();
            
                // ctx.fillStyle="green";
            
				
            // ctx.fillRect(0,0,pMines * 10,100);
				
            // // ctx.fill();
				
				ctx.clearRect(0, 0, 30, 30);
            ctx.save();
			
            ctx.strokeStyle = "#330000";
            ctx.font = '24px CURSIVE';
            ctx.textBaseline = 'hanging';
            ctx.strokeText(pMines, 0, 0);
			
        }
		function minesDraw(pMines){
            var Canvas = document.getElementById('mines');
            var ctx = Canvas.getContext('2d');
            ctx.clearRect(0, 0, 150, 20);
            ctx.save();	
				
				
            ctx.clearRect(0, 0, 150, 20);
            ctx.save();
            
                ctx.fillStyle="green";
            
				
            ctx.fillRect(0,0,pMines * 10,100);
				
            // ctx.fill();
				
				
            ctx.strokeStyle = "#330000";
            ctx.font = '16px CURSIVE';
            ctx.textBaseline = 'hanging';
            ctx.strokeText('BOMBS', 50, 0);
            ctx.restore();
			
        }
        function healthDraw(health11){
            var Canvas = document.getElementById('health11');
            var ctx = Canvas.getContext('2d');
            ctx.clearRect(0, 0, 150, 20);
            ctx.save();	
				
				
            ctx.clearRect(0, 0, 150, 20);
            ctx.save();
            if(health11 > 30)
                ctx.fillStyle="green";
            else
                ctx.fillStyle="red";
				
            ctx.fillRect(0,0,health11,100);
				
            // ctx.fill();
				
				
            ctx.strokeStyle = "#330000";
            ctx.font = '16px CURSIVE';
            ctx.textBaseline = 'hanging';
            ctx.strokeText('HEALTH', 50, 0);
            ctx.restore();
        }			

        function mapDraw() {
            var Canvas = document.getElementById('radar');
            var ctx = Canvas.getContext('2d');

            ctx.clearRect(0, 0, 200, 200);
            var xPos = localObject.position.x;
            var yPos = localObject.position.z;

            var xCor = 20000;
            var yCor = 20000;

            ctx.fillStyle = '#0000FF';
            ctx.fillRect(((yPos * 180) / 20000) + 90, (-(xPos * 180) / 20000) + 90, 10, 10);

            ctx.stroke();

            for (var i = 0; i < myWorld.noOfEnemies(); i++) {

                var xPosEnemy = enemyCarr[i].position.x;
                var yPosEnemy = enemyCarr[i].position.z;

                ctx.fillStyle = '#FF00FF';
                ctx.fillRect(((yPosEnemy * 180) / 20000) + 90, (-(xPosEnemy * 180) / 20000) + 90, 10, 10);

                ctx.stroke();
            }

            for (var k = 0; k < treesPositionX.length; k++) {

                var xPosTree = treesPositionX[k];
                var yPosTree = treesPositionZ[k];

                ctx.fillStyle = '#00FFFF';
                ctx.fillRect(((yPosTree * 180) / 20000) + 90, (-(xPosTree * 180) / 20000) + 90, 10, 10);

                ctx.stroke();
            }

            

        }
			
        
        function animate(runAnim) {

			
            setTimeout( function() {
                if(animatee)
                    requestAnimationFrame( animate );

            }, 1000 / 30 );
            // if(animatee)
            // requestAnimationFrame(animate);

            collision(car, collidableMeshList)

            collision(car, enemyCarr);
            // collision(enemyCarr, enemyCarr);
            //collision(car, enem);
            collision(car, boxArray);
            
            updateTime();
            for(var k = 0; k < myWorld.noOfEnemies(); k++){
                collision(enemyCarr[k], enemyCarr);
                if(k >= myWorld.noOfEnemies())
                    k = 0;
            }
            //renderer.clear();
            render();
            stats.update();
            

        }

        function createMines(obj, obj2) {
            var mineTexture = new THREE.ImageUtils.loadTexture( 'images/lava.jpg' );
            var sphere = new THREE.SphereGeometry(20,20,20);
            var boxMaterial = new THREE.MeshLambertMaterial({
                color : 0x000000,
                //shading : THREE.FlatShading,
                //overdraw : true,
                map : mineTexture
            });
			

           var bomb = new THREE.Mesh(sphere, boxMaterial);
			
            if (obj === undefined) {
                obj = localObject;
                obj2 = enemy;
            }
				
            // var bullet = new THREE.Mesh(bulletGeo, bulletMaterial);
            bomb.position.set(obj.position.x, (obj.position.y + 50) * 0.8, obj.position.z);
            // var originPoint = bullet.position.clone();

            if (obj === localObject) {
                var vector = camera.position.clone();
                bomb.ray = new THREE.Ray(obj.position, vector.subSelf(obj.position).normalize());
            } else {
                var vector = obj2.position.clone();
                bomb.ray = new THREE.Ray(obj.position, vector.subSelf(obj.position).normalize());
            }

            bomb.owner = obj;
            minesList.push(bomb);
            scene.add(bomb);
				
            return bomb;

        }
		
		
		function createBomb(xPos, yPos, zPos, obj) {
		
		
            // var mineTexture = new THREE.ImageUtils.loadTexture( 'images/lava.jpg' );
            // var sphere = new THREE.SphereGeometry(20,20,20);
            // var boxMaterial = new THREE.MeshLambertMaterial({
                // color : 0x000000,
                // //shading : THREE.FlatShading,
                // //overdraw : true,
                // map : mineTexture
            // });
			var darkMaterial = new THREE.MeshBasicMaterial( { color: 0xFF0000 } );
			var wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true} ); 
			var multiMaterial = [ darkMaterial, wireframeMaterial ];
			var bomb = THREE.SceneUtils.createMultiMaterialObject( 
			// radiusAtTop, radiusAtBottom, height, segmentsAroundRadius, segmentsAlongHeight,
			new THREE.CylinderGeometry( 30, 30, 10, 20, 4 ), 
			multiMaterial );
	//shape.position.set(-200, 50, -100);
	//scene.add( shape );
			

          // var bomb = new THREE.Mesh(sphere, boxMaterial);
			bomb.position.x = xPos;
			bomb.position.y = yPos;
			bomb.position.z = zPos;
            

            bomb.owner = obj;
            bombList.push(bomb);
            scene.add(bomb);
				
            return bomb;

        }

       
		
        function createEnemies2(){
			
			
            // var carGeometry = new THREE.CubeGeometry(400, 20, 150);
            // var carMaterial = new THREE.MeshLambertMaterial({
            // color : 0x000000,
            // //shading : THREE.FlatShading,
            // overdraw : true,
            // map : texture
            // });
            for (var k = 1; k <= myWorld.noOfEnemies(); k++) {
			
                text = new THREE.Texture();

                var loader = new THREE.ImageLoader();
                loader.addEventListener('load', function(event) {

                    text.image = event.content;
                    text.needsUpdate = true;

                });
                loader.load('images/0.jpg');
				
                var loader = new THREE.OBJMTLLoader();
                loader.addEventListener('load', function(event) {

                    object = event.content;

                    for (var i = 0, l = object.children.length; i < l; i++) {

                        object.children[i].material.map = text;
					
                    }
                    object.scale.x = object.scale.y = object.scale.z = 90;
                    // object.position.x = myWorld.enemyCar.position.x;
                    // object.position.y = 50;
                    // object.position.z = myWorld.enemyCar.position.z;
                    object.rotation.x = -(Math.PI) / 2;
                    object.rotation.z = (Math.PI) / 2;
					
                    arrayTrue.push(object);
                    //scene.add(object);

                });
                loader.load('objc/LP670/lp670.obj', 'objc/car/lp670.mtl');
				
					
            }
			
            return text;
        }
			
        function createEnemies(){
			
			
            var carGeometry = new THREE.CubeGeometry(400, 20, 150);
            var carMaterial = new THREE.MeshLambertMaterial({
                color : 0x000000,
                //shading : THREE.FlatShading,
                overdraw : true,
                map : texture
            });
            for (var k = 1; k <= myWorld.noOfEnemies(); k++) {

                Ncar = new THREE.Mesh(carGeometry, carMaterial);
                myWorld.setWorldEnemyCar(k);
                Ncar.position.x = myWorld.enemyCar.position.x + 10;
                Ncar.position.y = myWorld.enemyCar.position.y + 10;
                Ncar.position.z = myWorld.enemyCar.position.z;
					
                Ncar.castShoadow = true;
                Ncar.receiveShadow = true;
                Ncar.material.wireframe = true;
                Ncar.lastShot = Date.now();
                scene.add(Ncar);
                enemyCarr.push(Ncar);
					
                var texture11 = new THREE.Texture();

                var loader = new THREE.ImageLoader();
                loader.addEventListener('load', function(event) {

                    texture11.image = event.content;
                    texture11.needsUpdate = true;

                });
                loader.load('images/carss.jpg');
                var loader = new THREE.OBJMTLLoader();
                loader.addEventListener('load', function(event) {

                    object = event.content;

                    for (var i = 0, l = object.children.length; i < l; i++) {

                        object.children[i].material.map = texture11;

                    }
                    object.scale.x = object.scale.y = object.scale.z = 90;
                    object.position.x = myWorld.enemyCar.position.x;
                    object.position.y = 50;
                    object.position.z = myWorld.enemyCar.position.z;
                    object.rotation.x = -(Math.PI) / 2;
                    object.rotation.z = (Math.PI) / 2;
                    enemyModels.push(object);
                    scene.add(object);

                });
                loader.load('objc/LP670/lp670.obj', 'objc/car/lp670.mtl');
				
                var pointGeo = new THREE.CubeGeometry(50, 10, 20);
				
                var pointMaterial = new THREE.MeshBasicMaterial({
                    color : 0x00FF00,
                    //shading : THREE.FlatShading,
                    overdraw : true,
                    //map : texture
                });
				
                var pointLeft = new THREE.Mesh(pointGeo, pointMaterial);
                pointLeft.scale.x = 5;
               // pointRight = new THREE.Mesh(pointGeo, pointMaterial);
                scene.add(pointLeft);
                //scene.add(pointRight);
                leftPoint.push(pointLeft);
                //rightPoint.push(pointRight);
					
            }
        }
		
        function createBoxes(xPos, yPos, zPos) {
            var texture = new THREE.Texture();

            var loader = new THREE.ImageLoader();
            loader.addEventListener('load', function(event) {

                texture.image = event.content;
                texture.needsUpdate = true;

            });
            loader.load('objc/crate.gif');

            var boxGeometry = new THREE.CubeGeometry(190, 190, 190);
            var boxMaterial = new THREE.MeshLambertMaterial({
                color : 0x000000,
                //shading : THREE.FlatShading,
                overdraw : true,
                map : texture
            });

            box = new THREE.Mesh(boxGeometry, boxMaterial);
          
            box.position.x = xPos;
            box.position.y = yPos;
            box.position.z = zPos;
            box.castShoadow = true;
            box.receiveShadow = true;
            collidableMeshList.push(box);
            //box.material.wireframe = true;
            scene.add(box);
            boxSimpleArray.push(box);
        }
		
        function createBoxes2(xPos, yPos, zPos) {
            text2 = THREE.ImageUtils.loadTexture("images/fire.jpg");
            for (var i = 0; i < myWorld.noOfBox(); i++) {
          

                var boxGeometry = new THREE.CubeGeometry(190, 190, 190);
                var boxMaterial = new THREE.MeshLambertMaterial({
                    //color : 0x000000,
                    //shading : THREE.FlatShading,
                    overdraw : true,
                    map : text2
                });

                box = new THREE.Mesh(boxGeometry, boxMaterial);
           
                box.position.x = 150000;
                box.position.y = 150000;
                box.position.z = 150000;
                box.castShoadow = true;
                box.receiveShadow = true;
                collidableMeshList.push(box);
                //box.material.wireframe = true;
                scene.add(box);
                boxSimpleArray2.push(box);
            }
            return text2;
			
        }
		
        function avoidCollision(obj){
            for (var i = collidableMeshList.length - 1; i >= 0; i--) {
                var collideMesh = collidableMeshList[i];
                var v = collideMesh.geometry.vertices[0];
                var c = collideMesh.position;
                var x = Math.abs(v.x), z = Math.abs(v.z);

                if (distance(obj.position.x, obj.position.z, c.x,c.z) <= 500) {

                    return true;
                }
            }
            return false;
        }
        function createTrees(xPos, yPos, zPos) {
            //mapDrawTree(zPos, xPos);
            treesPositionX[treeIndex] = xPos;
            treesPositionZ[treeIndex] = zPos;
            treeIndex++;
            var texture1 = new THREE.Texture();

            var loader = new THREE.ImageLoader();
            loader.addEventListener('load', function(event) {

                texture1.image = event.content;
                texture1.needsUpdate = true;

            });
            loader.load('objc/normal_L1010014.jpg');

            // model

            var loader = new THREE.OBJLoader();
            loader.addEventListener('load', function(event) {

                var object = event.content;

                for (var i = 0, l = object.children.length; i < l; i++) {

                    object.children[i].material.map = texture1;

                }
                object.scale.x = object.scale.y = object.scale.z = 5;
                object.position.x = xPos;
                object.position.y = 0;
                object.position.z = zPos;
                object.rotation.x = -(Math.PI) / 2;
                //objects.push(object);
                scene.add(object);

            });
            loader.load('objc/Palm_Tree.obj');

            var texture = THREE.ImageUtils.loadTexture("objc/crate.gif");
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(.5, .5);
            var boxGeometry = new THREE.CubeGeometry(30, 650, 30);
            var boxMaterial = new THREE.MeshLambertMaterial({
                // color : 0x5CD715,
                shading : THREE.FlatShading,
                overdraw : true,
                map : texture

            });

            box = new THREE.Mesh(boxGeometry, boxMaterial);

            box.position.x = xPos;
            box.position.y = 0;
            box.position.z = zPos;
            box.castShadow = true;
            box.transparent = true;
            collidableMeshList.push(box);
            //	box.material.wireframe = true;
            scene.add(box);

        }
		
        function swapModels(mesh, modelOne, modelTwo){
		
            if(mesh.position.x != 150000){
                modelOne.position.x = mesh.position.x;
                modelOne.position.z = mesh.position.z;
                modelOne.position.y = mesh.position.y + 10;
                modelOne.rotation.z = modelTwo.rotation.z;
							
                scene.add(modelOne);
				
            }
            mesh.position.x = 150000;
            mesh.position.z = 150000;
            var sound2 = new Sound( [ 'audios/blast.mp3'], 275, 1 );
            sound2.play();
			
			nextLevel--;
			if(nextLevel == 0)
			nextround();
        }

        function distance(x1, y1, x2, y2) {

            var dis = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            return dis;
        }

        function checkHit(bullet) {

            for (var i = collidableMeshList.length - 1; i >= 0; i--) {
                var collideMesh = collidableMeshList[i];
                var v = collideMesh.geometry.vertices[0];
                var c = collideMesh.position;
                var x = Math.abs(v.x), z = Math.abs(v.z);

                if (bullet.x < c.x + x && bullet.x > c.x - x && bullet.z < c.z + z && bullet.z > c.z - z) {

                    return true;
                }
            }

            return false;
        }

        function render() {
				
			bulletDraw(myWorld.getBulletsOfPlayer());	
            bombDraw(myWorld.getBombOfPlayer());
			mineDraw(myWorld.getMinesOfPlayer());
            speedDraw();
            healthDraw(myWorld.healthControl());
            if(myWorld.healthControl() <= 100){
			
                setMaterial(localObject, new THREE.MeshBasicMaterial({ map:carTexture}));
            }
            //console.log(myWorld.healthControl() + "heath");
            mapDraw();
			
            healthcube.rotation.x += 0.04
            healthcube.rotation.y += 0.008;
            // Allow picking it up once per minute
            var health = myWorld.healthControl();
            if (Date.now() > lastHealthPickup + 60000) {
                if (distance(localObject.position.x, localObject.position.z, healthcube.position.x, healthcube.position.z) <= 150 && health != 150) {
                    health = Math.min(health + 50, 150);
                    //$('#health').html(health);
                    myWorld.setHealthControl(health);
                    lastHealthPickup = Date.now();
                }
                healthcube.material.wireframe = false;
            }
            else {
                healthcube.material.wireframe = true;
            }  

bombCube.rotation.x += 0.04
            bombCube.rotation.y += 0.008;
            // Allow picking it up once per minute
            var count = myWorld.getBombOfPlayer();
            if (Date.now() > lastHealthPickup + 60000) {
                if (distance(localObject.position.x, localObject.position.z, bombCube.position.x, bombCube.position.z) <= 150 && count != 15) {
                    count = Math.min(count + 10, 15);
                    //$('#health').html(health);
                    myWorld.setBombCount(count);
                    lastHealthPickup = Date.now();
                }
                bombCube.material.wireframe = false;
            }
            else {
                bombCube.material.wireframe = true;
            } 
mineCube.rotation.x += 0.04
            mineCube.rotation.y += 0.008;
            // Allow picking it up once per minute
            var countMines = myWorld.getMinesOfPlayer();
            if (Date.now() > lastHealthPickup + 60000) {
                if (distance(localObject.position.x, localObject.position.z, mineCube.position.x, mineCube.position.z) <= 150 && countMines != 15) {
                    countMines = Math.min(countMines + 7, 15);
                    //$('#health').html(health);
                    myWorld.setMineCount(countMines);
                    lastHealthPickup = Date.now();
                }
                mineCube.material.wireframe = false;
            }
            else {
                mineCube.material.wireframe = true;
            } 			
            //console.log("above the terrain " + bBox.max.y + " " + cellZ + " " + cellX);
            for (var j = enemyCarr.length - 1; j >= 0; j--) {

                enemy = enemyCarr[j];
                collision(enemy, collidableMeshList, j);
                collision(enemy, collidableMesh, j);

                var dist = distance(enemy.position.x, enemy.position.z, localObject.position.x, localObject.position.z);

                if (dist < 600 && Date.now() > enemy.lastShot + 750) {
                    object = createBullet(enemy, localObject);
                    enemy.lastShot = Date.now();
                    var sound2 = new Sound( [ 'audios/bulletFire.mp3'], 275, 1 );
                    sound2.play();
                    // var snd = new Audio("audios/bulletFire.mp3"); // buffers automatically when created
                    // snd.play();
                }
                if (dist < 2000 && Date.now() > enemy.lastShot + 2000) {
                    object = createMines(enemy, localObject);
                    enemy.lastShot = Date.now();
                }
				if (dist <= 1000 && Date.now() > enemy.lastShot + 1000) {
				var eRN = enemyModels[j].rotation.z + enemyModels[j].rotation.x;
				
                    object = createBomb(enemyCarr[j].position.x - (Math.cos(eRN) * 200 ), 30, enemyCarr[j].position.z + (Math.sin(eRN) * 200 ), enemyCarr[j]);
                    enemy.lastShot = Date.now();
                }
            }
            //scene.remove(car);

            var delta = cloc.getDelta();
				
            // customUniforms.time.value += .5 * delta;
            boomer.update(500 * delta);
            boomer1.update(500 * delta);
			
			var bombHit = false;
			for(var m = bombList.length -1; m >=0; m--){
			 var bomb = bombList[m];
			 
			 dist = distance(bomb.position.x, bomb.position.z, localObject.position.x, localObject.position.z);
               // console.log("distL " + dist);
                if (dist <= 150) {
                    $('#hurt').fadeIn(75);
                    myWorld.setHealthControl(0);
                    //speed = myWorld.CarMove("W", true);
                    //$('#health').html(myWorld.healthControl());
                    if (myWorld.healthControl() <= 0) {
                        //self.stopAnimating();
                        runAnim = false;
						 setMaterial(localObject, new THREE.MeshBasicMaterial({ map:text}));
                        animatee = false;
                        
                        var sound2 = new Sound( [ 'audios/blast.mp3'], 275, 1 );
                        sound2.play();
                        
                        gameMenu();
                    }
                    bombList.splice(m, 1);
                    scene.remove(bomb);
                    $('#hurt').fadeOut(350);

                }
				
                for (var j = enemyCarr.length - 1; j >= 0; j--) {

                    enemy = enemyCarr[j];

                    var dist = distance(enemy.position.x, enemy.position.z, bomb.position.x, bomb.position.z);

                    if (dist <= 150) {

                        //if (j == 0) {
                        leftPoint[j].scale.x -= .5;
                        if(leftPoint[j].scale.x <= 1.5)
                            leftPoint[j].material.color.setHex(0xff0000);
						
                        myWorld.setEnemyHealthControl(j, 0);
                        if (myWorld.enemyHealthControl(j) <= 0) {
							
                            swapModels(enemyCarr[j], arrayTrue[j], enemyModels[j]);
                           

                        }

                        bombList.splice(m, 1);
                        scene.remove(bomb);
                      
                    }
                }
			 
			}
			
            var mineHit = false;
            for(var k = minesList.length - 1; k >= 0; k--){
				
				var bombSpeed = 5000 * delta;
                var mine = minesList[k];
                d = mine.ray.direction;

                if (checkHit(mine.position) === true) {
                    mineHit = true;
                    minesList.splice(k, 1);
                    scene.remove(mine);
                }
                if (checkHit(localObject.position) === true) {
                    speed = myWorld.CarMove("W", true);
                }

                if (!mineHit && mine.owner != localObject) {
                    //b.rotation.x = Math.PI / 2;
                    //b.translateX(bspeed * (d.x));
                    mine.position.x += bombSpeed * (d.x);
                    mine.position.z += bombSpeed * (d.z);
                    //b.translateZ(bspeed * (d.z));
                    // bulletObj.translateX(bspeed * (d.x));
                    // bulletObj.translateZ(bspeed * (d.z));

                }

                if (!mineHit && mine.owner == localObject) {
                    //b.rotation.x = Math.PI / 2;
                    // b.translateX(bspeed * -(d.x));
                    // b.translateZ(bspeed * -(d.z));
                    mine.position.x += bombSpeed * -(d.x);
                    mine.position.z += bombSpeed * -(d.z);
						
                }
                dist = distance(mine.position.x, mine.position.z, localObject.position.x, localObject.position.z);
               // console.log("distL " + dist);
                if (dist <= 150 && mine.owner != localObject) {
                    $('#hurt').fadeIn(75);
                    myWorld.setHealthControl(myWorld.healthControl() - 20);
                    //speed = myWorld.CarMove("W", true);
                    //$('#health').html(myWorld.healthControl());
                    if (myWorld.healthControl() <= 0) {
                        //self.stopAnimating();
                        runAnim = false;
						 setMaterial(localObject, new THREE.MeshBasicMaterial({ map:text}));
                        animatee = false;
                        
                        var sound2 = new Sound( [ 'audios/blast.mp3'], 275, 1 );
                        sound2.play();
                        
                        gameMenu();
                    }
                    minesList.splice(k, 1);
                    scene.remove(mine);
                    $('#hurt').fadeOut(350);

                }
				
                for (var j = enemyCarr.length - 1; j >= 0; j--) {

                    enemy = enemyCarr[j];

                    var dist = distance(enemy.position.x, enemy.position.z, mine.position.x, mine.position.z);

                    if (dist <= 150 && mine.owner === localObject) {

                        //if (j == 0) {
                        leftPoint[j].scale.x -= .5;
                        if(leftPoint[j].scale.x <= 1.5)
                            leftPoint[j].material.color.setHex(0xff0000);
						
                        myWorld.setEnemyHealthControl(j, myWorld.enemyHealthControl(j) - 20);
                        if (myWorld.enemyHealthControl(j) <= 0) {
							
                            swapModels(enemyCarr[j], arrayTrue[j], enemyModels[j]);
                           

                        }

                        minesList.splice(k, 1);
                        scene.remove(mine);
                      
                    }
                }
				
				for (var j = boxSimpleArray.length - 1; j >= 0; j--) {

                    //box = boxSimpleArray[j];

                    var dist = distance(boxSimpleArray[j].position.x, boxSimpleArray[j].position.z, mine.position.x, mine.position.z);
	
                    if (dist <= 150) {

                        					
                      
                        if (myWorld.boxHealthControl(j) <= 0) {
							
                            
                            if(boxSimpleArray[j].position.x != 150000){
                                boxSimpleArray2[j].position.x = boxSimpleArray[j].position.x;
                                boxSimpleArray2[j].position.z = boxSimpleArray[j].position.z;
                                boxSimpleArray2[j].position.y = boxSimpleArray[j].position.y;
                                
                            }
                            boxSimpleArray[j].position.x = 150000;
                            boxSimpleArray[j].position.z = 150000;
							

                        }

                        minesList.splice(k, 1);
                        scene.remove(mine);
                        
                    }

                  
                }
				
            }

				

            var hit = false;
				
				
            for (var i = bullets.length - 1; i >= 0; i--) {
                var bspeed = delta * 5000;
                var b = bullets[i];
                //createMines(b.position.x, 20, b.position.z);
                //	scene.remove(mines);

                d = b.ray.direction;

                if (checkHit(b.position) === true) {
                    hit = true;
                    bullets.splice(i, 1);
                    scene.remove(b);
                }

                if (checkHit(localObject.position) === true) {
                    speed = myWorld.CarMove("W", true);
                }

                if (!hit && b.owner != localObject) {
                    //b.rotation.x = Math.PI / 2;
                    //b.translateX(bspeed * (d.x));
                    b.position.x += bspeed * (d.x);
                    b.position.z += bspeed * (d.z);
                    //b.translateZ(bspeed * (d.z));
                    // bulletObj.translateX(bspeed * (d.x));
                    // bulletObj.translateZ(bspeed * (d.z));

                }

                if (!hit && b.owner == localObject) {
                    //b.rotation.x = Math.PI / 2;
                    // b.translateX(bspeed * -(d.x));
                    // b.translateZ(bspeed * -(d.z));
                    b.position.x += bspeed * -(d.x);
                    b.position.z += bspeed * -(d.z);
						
                }
					
					
                dist = distance(b.position.x, b.position.z, localObject.position.x, localObject.position.z);
                if (dist < 150 && b.owner != localObject) {
                    $('#hurt').fadeIn(75);
                    myWorld.healthControlreduce();
                    //speed = myWorld.CarMove("W", true);
                    //$('#health').html(myWorld.healthControl());
                    if (myWorld.healthControl() <= 0) {
                        //self.stopAnimating();
                        runAnim = false;
						 setMaterial(localObject, new THREE.MeshBasicMaterial({ map:text}));
                        animatee = false;
                        
                        var sound2 = new Sound( [ 'audios/blast.mp3'], 275, 1 );
                        sound2.play();
						
						gameMenu();
                       
                    }
                    bullets.splice(i, 1);
                    scene.remove(b);
                    //bulletObj.position.x = 10000;
                    $('#hurt').fadeOut(350);

                }

                for (var j = enemyCarr.length - 1; j >= 0; j--) {

                    enemy = enemyCarr[j];

                    var dist = distance(enemy.position.x, enemy.position.z, b.position.x, b.position.z);

                    if (dist < 150 && b.owner == localObject) {

                        //if (j == 0) {
                        leftPoint[j].scale.x -= .5;
                        if(leftPoint[j].scale.x <= 1.5)
                            leftPoint[j].material.color.setHex(0xff0000);
						
                        
                        if (myWorld.enemyHealthControl(j) <= 0) {
							
                            swapModels(enemyCarr[j], arrayTrue[j], enemyModels[j]);
							
                        }

                        bullets.splice(i, 1);
                        scene.remove(b);
                        //Nspeed = myWorld.setEnemyCarSpeed(timer, true, j);
                    }

                    //scene.remove(enemy);
                }
				
				
				
                /////////////////////////////////////////BOX MODEL///////////////////////////////////////////
                //var box;
                for (var j = boxSimpleArray.length - 1; j >= 0; j--) {

                    //box = boxSimpleArray[j];

                    var dist = distance(boxSimpleArray[j].position.x, boxSimpleArray[j].position.z, b.position.x, b.position.z);
	
                    if (dist <= 150) {

                        					
                      
                        if (myWorld.boxHealthControl(j) <= 0) {
							
                            
                            if(boxSimpleArray[j].position.x != 150000){
                                boxSimpleArray2[j].position.x = boxSimpleArray[j].position.x;
                                boxSimpleArray2[j].position.z = boxSimpleArray[j].position.z;
                                boxSimpleArray2[j].position.y = boxSimpleArray[j].position.y;
                                
                            }
                            boxSimpleArray[j].position.x = 150000;
                            boxSimpleArray[j].position.z = 150000;
							

                        }

                        bullets.splice(i, 1);
                        scene.remove(b);
                        
                    }

                  
                }
				
				

            }
            //localObject.rotation.y = -.5
            var rotationAngle = 0.05 * Math.abs(speed / 10);
            if (rotationAngle > 0.05)
                rotationAngle = 0.05;

            if (keyboard.pressed("A")) {
                localObject.rotation.z += rotationAngle;

                if (localObject.rotation.z > 6)
                    localObject.rotation.z -= 6;
            }

            if (keyboard.pressed("D")) {
                localObject.rotation.z -= rotationAngle;
                if (localObject.rotation.z < 0)
                    localObject.rotation.z = 6 + localObject.rotation.z;
            }
            if (keyboard.pressed("W")) {
                //speed += acceleration;

                speed = myWorld.CarMove("W", false);

                $('#speed').html(speed);

            }
            if (keyboard.pressed("S")) {

                speed = myWorld.CarMove("S", false);
                $('#speed').html(speed);

            }
            if (keyboard.pressed("up")) {
                cameraYPos += cameraYPos > 500 ? 0 : 10;
            }
            if (keyboard.pressed("down")) {
                cameraYPos -= cameraYPos <= 0 ? 0 : 10;
            }

            if (!keyboard.pressed("W") && !keyboard.pressed("S")) {

                myWorld.CarMove("F", false);

                $('#speed').html(speed);

            }
            // if (keyboard.pressed("P")) {
            // gameMenu();

            // }
            if (keyboard.pressed("space") && myWorld.getMinesOfPlayer() > 0) {
                
                myWorld.reduceMinesOfPlayer();
			var eR = localObject.rotation.x + localObject.rotation.z;
               object = createBomb(localObject.position.x - (Math.cos(eR) * 300 ), 30, localObject.position.z +  (Math.sin(eR) * 300 ));
                
				
            }
            // if (keyboard.pressed("Z") ) {
			
            // }
               

            

            // ==================================NEW ENEMY CAR=================================================s

            // update car position
            var phaseX = 1;
            var phaseY = 1;
            //var eR = myWorld.myCar.rotation.y;
            var eR = localObject.rotation.x + localObject.rotation.z;
            car.rotation.y = localObject.rotation.x + localObject.rotation.z;
            //		wheel.rotation.y = localObject.rotation.x + localObject.rotation.z;
            var computedX = (localObject.position.x + ((speed * Math.cos(eR)) * phaseX));
            var computedZ = (localObject.position.z - ((speed * Math.sin(eR)) * phaseY));
				

            localObject.position.x = computedX;
            localObject.position.z = computedZ;
            //localObject.rotation.y = computedY;
            car.position.x = computedX;
            car.position.z = computedZ;
			
            
            // =========================NEW ENEMY CAR========================================
            // move = 'R';
            var defference = 0;
            //var hitDirection = false;
				
            if (enemyModels.length != 0 && arrayTrue.length != 0){
				
				
				
                for (var k = 0; k < myWorld.noOfEnemies(); k++) {

//                    var enemyCordinates = getEnemyCordinates(enemyCarr[k].position.x, enemyCarr[k].position.z);
  //                  var playerCordinates = getPlayerCordinates(localObject.position.x, localObject.position.z);
					
                    getDirection(enemyCarr[k], cameraArray[k], localObject);
					
                    
                    var b;
                    for (var i = checkDirection.length - 1; i >= 0; i--) {
                        b = checkDirection[i];
                        //createMines(b.position.x, 20, b.position.z);
                        //	scene.remove(mines);
                        var bspeed = delta * 5000;
                        d = b.ray.direction;
                        b.position.x += bspeed * -(d.x);
                        b.position.z += bspeed * -(d.z);

                        if (b.owner === enemyCarr[k] && distance (b.position.x, b.position.z, localObject.position.x, localObject.position.z) <= 300){
                            //move = 'L';
                            //var index = k;
                            hitDirection = true;
                            hitObj = enemyCarr[k];
                            scene.remove(b);
                           
                        }
                    }
					
                    if (hitDirection == true && hitObj == enemyCarr[k]){
					
                        enemyModels[k].rotation.z = myWorld.setEnemyCarRotation('S', enemyModels[k].rotation.z, k);
                        enemyCarr[k].rotation.y = enemyModels[k].rotation.z + enemyModels[k].rotation.x;
                        leftPoint[k].rotation.x =  enemyModels[k].rotation.x;
                        leftPoint[k].rotation.z =  enemyModels[k].rotation.z;
					
                        var eRN = enemyModels[k].rotation.z + enemyModels[k].rotation.x;
                        cameraArray[k].position.x = enemyCarr[k].position.x - (Math.cos(eRN) * 500 );
                        cameraArray[k].position.z = enemyCarr[k].position.z + (Math.sin(eRN) * 500 );
                        cameraArray[k].lookAt(enemyCarr[k].position);
					
                        // rightPoint[k].position.x = enemyCarr[k].position.x - (Math.cos(eRN) * 500 );
                        // rightPoint[k].position.z = enemyCarr[k].position.z + (Math.sin(eRN) * 500 );
                        leftPoint[k].position.y = 150;
					
                        if (distance (enemyCarr[k].position.x, enemyCarr[k].position.z, localObject.position.x, localObject.position.z) <= 600){
                            enemyCarr[k].position.x = myWorld.setEnemyCarNewPositionX(myWorld.setEnemyCarSpeed('L', false, k), eRN, enemyCarr[k].position.x, k);
                            enemyCarr[k].position.z = myWorld.setEnemyCarNewPositionZ(myWorld.setEnemyCarSpeed('L', false, k), eRN, enemyCarr[k].position.z, k);
                        }
                        else{
                            enemyCarr[k].position.x = myWorld.setEnemyCarNewPositionX(myWorld.setEnemyCarSpeed('R', false, k), eRN, enemyCarr[k].position.x, k);
                            enemyCarr[k].position.z = myWorld.setEnemyCarNewPositionZ(myWorld.setEnemyCarSpeed('R', false, k), eRN, enemyCarr[k].position.z, k);
                        }
					
                        enemyModels[k].position.x = enemyCarr[k].position.x;
                        enemyModels[k].position.z = enemyCarr[k].position.z;
						
                        leftPoint[k].position.x = enemyCarr[k].position.x;
                        leftPoint[k].position.z = enemyCarr[k].position.z;
						
						
                        //hitDirection = false;
                    }
                    else{
                        enemyModels[k].rotation.z = myWorld.setEnemyCarRotation(move, enemyModels[k].rotation.z, k);
                        enemyCarr[k].rotation.y = enemyModels[k].rotation.z + enemyModels[k].rotation.x;
                        leftPoint[k].rotation.x =  enemyModels[k].rotation.x;
                        leftPoint[k].rotation.z =  enemyModels[k].rotation.z;
					
                        var eRN = enemyModels[k].rotation.z + enemyModels[k].rotation.x;
                        cameraArray[k].position.x = enemyCarr[k].position.x - (Math.cos(eRN) * 500 );
                        cameraArray[k].position.z = enemyCarr[k].position.z + (Math.sin(eRN) * 500 );
                        cameraArray[k].lookAt(enemyCarr[k].position);
					
                        // rightPoint[k].position.x = enemyCarr[k].position.x - (Math.cos(eRN) * 500 );
                        // rightPoint[k].position.z = enemyCarr[k].position.z + (Math.sin(eRN) * 500 );
                        leftPoint[k].position.y = 150;
					
                        if (distance (enemyCarr[k].position.x, enemyCarr[k].position.z, localObject.position.x, localObject.position.z) <= 600){
                            enemyCarr[k].position.x = myWorld.setEnemyCarNewPositionX(myWorld.setEnemyCarSpeed('L', false, k), eRN, enemyCarr[k].position.x, k);
                            enemyCarr[k].position.z = myWorld.setEnemyCarNewPositionZ(myWorld.setEnemyCarSpeed('L', false, k), eRN, enemyCarr[k].position.z, k);
                        }
                        else{
                            enemyCarr[k].position.x = myWorld.setEnemyCarNewPositionX(myWorld.setEnemyCarSpeed('R', false, k), eRN, enemyCarr[k].position.x, k);
                            enemyCarr[k].position.z = myWorld.setEnemyCarNewPositionZ(myWorld.setEnemyCarSpeed('R', false, k), eRN, enemyCarr[k].position.z, k);
                        }
					
                        enemyModels[k].position.x = enemyCarr[k].position.x;
                        enemyModels[k].position.z = enemyCarr[k].position.z;
						
                        leftPoint[k].position.x = enemyCarr[k].position.x;
                        leftPoint[k].position.z = enemyCarr[k].position.z;
					
                    }
					
                    if (k > myWorld.noOfEnemies()) {
                        k = 0;

                    }
					

                }
            }
            //=======================old car speed==================================

            if (speed > 0)
                speed = speed - speedDamping;
            else
                speed = 0;

            if (speed > maxSpeed)
                speed = maxSpeed;

      

            camera.position.x = localObject.position.x - (Math.cos(eR) * 500 );
            camera.position.z = localObject.position.z + (Math.sin(eR) * 500 );

            camera.position.y = cameraYPos;
            camera.lookAt(localObject.position);
				
            //camera.lookAt(Ncar.position);
            renderer.shadowMapEnabled = true;
            renderer.render(scene, camera);

        }

    </script>

</body>
</html>
