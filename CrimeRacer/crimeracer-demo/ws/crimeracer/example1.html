<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
			
				font-family: Monospace;
				background-color: #cccccc;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
	

		<script src="threejs/build/three.min.js"></script>
		<script src="threejs/build/CollisionUtils.js"></script>
		<script src="threejs/build/Collisions.js"></script>
		<script src="threejs/build/Stats.js"></script>
		<script src="extras/THREEx.KeyboardState.js"></script>
		<script src="objects/car.js"></script>

		<script>
			var container, stats;
			var camera, scene, renderer;
			var sphere;
			var car;
			var speed = 1;
			var acceleration = 3;
			var speedDamping = 1;
			var maxSpeed = 20;
			var cameraYPos = 500;
			var mycar; 
			var box;
			var textu;
			var cubes = [];
			init();
			animate();
			

			function init() {

				container = document.createElement('div');
				document.body.appendChild(container);

				var info = document.createElement('div');
				// info.style.position = 'absolute';
				// info.style.top = '100%';
				// info.style.width = '100%';
				// info.style.textAlign = 'center';
				//info.innerHTML = '<a href="http://github.com/mrdoob/three.js" target="_blank">three.js</a> - demo by recluze';
				container.appendChild(info);

				// camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -2000, 1000);
				camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 2, 2500);

				// camera.position.x = 200;
				// camera.position.y = 50;
				// camera.position.z = 200;
				
				camera.position.set( 2000, 2000, 2000 );
				
				

				scene = new THREE.Scene();

				
				
				
				var texture = THREE.ImageUtils.loadTexture( "images/road.jpg" );
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set( 3, 3 );

				groundBasic = new THREE.MeshLambertMaterial( { /*color: 0x5c6b68,*/ map: texture } );
				//groundBasic.color.setHSV( 0.1, 0.45, 0.995 );

				ground = new THREE.Mesh( new THREE.PlaneGeometry( 10000, 10000, 80,80), groundBasic );
				ground.position.y = 0;
				ground.rotation.x = (- Math.PI / 2) ;
				 ground.rotation.z = Math.PI / 2;
				//ground.rotation.y = -Math.PI / 2;
				ground.receiveShadow = true;
				scene.add( ground );
				
				
				
				
				//Geometry

				var geometry = new THREE.SphereGeometry(50);
				var material = new THREE.MeshLambertMaterial({
					color : 0xffffff,
					shading : THREE.FlatShading,
					overdraw : true
				});
				
				
				sphere = new THREE.Mesh(geometry, material);
				sphere.position.x = 100;
				sphere.position.y = 50;
				sphere.position.z = -50;
				scene.add(sphere);
				
				// Box
				
				var boxGeometry = new THREE.CubeGeometry(200, 200, 200);
				var boxMaterial = new THREE.MeshLambertMaterial({
					color : 0xffffff,
					shading : THREE.FlatShading,
					overdraw : true
					
				});

				box = new THREE.Mesh(boxGeometry, boxMaterial);
				scene.add(box);
				box.position.x = 1000;
				box.position.y = 100;
				box.position.z = 500;
				
				THREE.Collisions.colliders.push( THREE.CollisionUtils.MeshOBB( box ) );
				cubes.push(box);
				
				
				//Another Box
				var j=0;
				for (var i=0; i<5; i++){
				
				var boxGeometry = new THREE.CubeGeometry(200, 200, 500);
				var boxMaterial = new THREE.MeshLambertMaterial({
					color : 0xffffff,
					shading : THREE.FlatShading,
					overdraw : true
					
				});

				 box = new THREE.Mesh(boxGeometry, boxMaterial);
				scene.add(box);
				box.position.x = 4000;
				box.position.y = 100;
				box.position.z = 500 + j;
				j+=500;
				}
				
				// Mid Plane
				
				// var planeGeo = new THREE.PlaneGeometry(100, 100);
				// var planeMetrial = new THREE.MeshLambertMaterial({
				// color: 0xffffff,
				// //shading : THREE.FlatShading,
				// //overdraw : true
				// });
				
				// var mid = new THREE.Mesh(planeGeo, planeMetrial);
				// scene.add(mid);
				// mid.position.x = 0;
				// mid.position.y = 10;
				// mid.position.z = 1600;
				//mid.rotation.x = -(Math.PI / 2);
				
				// Cubes

				var carGeometry = new THREE.CubeGeometry(100, 50, 50);
				var carMaterial = new THREE.MeshLambertMaterial({
					color : 0xffffff,
					shading : THREE.FlatShading,
					overdraw : true
				});
				car = new THREE.Mesh(carGeometry, carMaterial);
				car.position.x = 50;
				car.position.y = 30;
				car.position.z = 100;
				scene.add(car);
				THREE.Collisions.colliders.push( THREE.CollisionUtils.MeshOBB( car ) );
				cubes.push(car);
				
		
				//THREE.Collisions.colliders.push( THREE.CollisionUtils.MeshOBB( car ) );
				
	


				// Lights

				var ambientLight = new THREE.AmbientLight(/*Math.random() * 0x10*/0xc9ac45);
				scene.add(ambientLight);

				var directionalLight = new THREE.DirectionalLight(/*Math.random() * 0xffffff*/0xc9ac45);
				directionalLight.position.x = Math.random() - 0.5;
				directionalLight.position.y = Math.random() - 0.5;
				directionalLight.position.z = Math.random() - 0.5;
				directionalLight.position.normalize();
				scene.add(directionalLight);

				var directionalLight = new THREE.DirectionalLight(/*Math.random() * 0xffffff*/0xc9ac45);
				directionalLight.position.x = Math.random() - 0.5;
				directionalLight.position.y = Math.random() - 0.5;
				directionalLight.position.z = Math.random() - 0.5;
				directionalLight.position.normalize();
				scene.add(directionalLight);

				renderer = new THREE.CanvasRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);

				container.appendChild(renderer.domElement);

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild(stats.domElement);

				//keyboard
				keyboard = new THREEx.KeyboardState();

				window.addEventListener('resize', onWindowResize, false);

				mycar = new CrimeRacer.Car; 
				mycar.move(1, 0, 0);
				console.log(mycar.position.x);
			}

			function onWindowResize() {

				camera.left = window.innerWidth / -2;
				camera.right = window.innerWidth / 2;
				camera.top = window.innerHeight / 2;
				camera.bottom = window.innerHeight / -2;

				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

			}

			//

			function animate() {

				requestAnimationFrame(animate);

				render();
				stats.update();

			}

			function render() {

				var rotationAngle = 0.05 * Math.abs(speed / 10);
				if (rotationAngle > 0.05)
					rotationAngle = 0.05;

				if (keyboard.pressed("left")) {
					car.rotation.y += rotationAngle;
					if (car.rotation.y > 6)
						car.rotation.y -= 6;
				}

				if (keyboard.pressed("right")) {
					car.rotation.y -= rotationAngle;
					if (car.rotation.y < 0)
						car.rotation.y = 6 + car.rotation.y;
				}
				if (keyboard.pressed("up")) {
					speed += acceleration;
				}
				if (keyboard.pressed("down")) {
					speed -= acceleration;
				}
				if (keyboard.pressed("W")) {
					cameraYPos += cameraYPos > 500 ? 0 : 10;
				}
				if (keyboard.pressed("S")) {
					cameraYPos -= cameraYPos <= 0 ? 0 : 10;
				}
				
				

				var timer = Date.now() * 0.0001;

				// update car position
				var phaseX = 1;
				var phaseY = 1;
				var eR = car.rotation.y;

				var computedX = (car.position.x + ((speed * Math.cos(eR)) * phaseX));
				var computedZ = (car.position.z - ((speed * Math.sin(eR)) * phaseY));

				if ((Math.abs(computedX - sphere.position.x) < 100) && (Math.abs(computedZ - sphere.position.z) < 100)) {
					computedX = car.position.x;
					computedZ = car.position.z;
				}

				car.position.x = computedX;
				car.position.z = computedZ;
				
				if(car.position == box.position){
				
				console.log("X: " + car.position.x  );
				console.log("X box: " + box.position.x  );
				}

				  //console.log("X: " + car.position.x  );
				//  console.log("Z: " + car.position.z  );
				if (speed > 0)
					speed = speed - speedDamping;
				else
					speed = 0;

				if (speed > maxSpeed)
					speed = maxSpeed;

				 // camera.position.x = Math.cos(timer) * 200;
				 // camera.position.z = Math.sin(timer) * 200;
				 camera.position.x = car.position.x - (Math.cos(eR) * 500 );
				camera.position.z = car.position.z + (Math.sin(eR) * 500 );
				camera.position.y = cameraYPos;
				 camera.lookAt(car.position); 
				//camera.lookAt(cameraTarget);
				
				renderer.render(scene, camera);

			}

		</script>

	</body>
</html>
